// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoklav.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_autoklav_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_autoklav_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_autoklav_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_autoklav_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoklav_2eproto;
namespace Autoklav {
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class ProcessConfig;
struct ProcessConfigDefaultTypeInternal;
extern ProcessConfigDefaultTypeInternal _ProcessConfig_default_instance_;
class ProcessInfo;
struct ProcessInfoDefaultTypeInternal;
extern ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
class ProcessLogRow;
struct ProcessLogRowDefaultTypeInternal;
extern ProcessLogRowDefaultTypeInternal _ProcessLogRow_default_instance_;
class SensorValues;
struct SensorValuesDefaultTypeInternal;
extern SensorValuesDefaultTypeInternal _SensorValues_default_instance_;
class SetVariable;
struct SetVariableDefaultTypeInternal;
extern SetVariableDefaultTypeInternal _SetVariable_default_instance_;
class StartProcessRequest;
struct StartProcessRequestDefaultTypeInternal;
extern StartProcessRequestDefaultTypeInternal _StartProcessRequest_default_instance_;
class StateMachineValues;
struct StateMachineValuesDefaultTypeInternal;
extern StateMachineValuesDefaultTypeInternal _StateMachineValues_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Variables;
struct VariablesDefaultTypeInternal;
extern VariablesDefaultTypeInternal _Variables_default_instance_;
}  // namespace Autoklav
PROTOBUF_NAMESPACE_OPEN
template<> ::Autoklav::Empty* Arena::CreateMaybeMessage<::Autoklav::Empty>(Arena*);
template<> ::Autoklav::ProcessConfig* Arena::CreateMaybeMessage<::Autoklav::ProcessConfig>(Arena*);
template<> ::Autoklav::ProcessInfo* Arena::CreateMaybeMessage<::Autoklav::ProcessInfo>(Arena*);
template<> ::Autoklav::ProcessLogRow* Arena::CreateMaybeMessage<::Autoklav::ProcessLogRow>(Arena*);
template<> ::Autoklav::SensorValues* Arena::CreateMaybeMessage<::Autoklav::SensorValues>(Arena*);
template<> ::Autoklav::SetVariable* Arena::CreateMaybeMessage<::Autoklav::SetVariable>(Arena*);
template<> ::Autoklav::StartProcessRequest* Arena::CreateMaybeMessage<::Autoklav::StartProcessRequest>(Arena*);
template<> ::Autoklav::StateMachineValues* Arena::CreateMaybeMessage<::Autoklav::StateMachineValues>(Arena*);
template<> ::Autoklav::Status* Arena::CreateMaybeMessage<::Autoklav::Status>(Arena*);
template<> ::Autoklav::Variables* Arena::CreateMaybeMessage<::Autoklav::Variables>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Autoklav {

enum ProcessConfigType : int {
  STERILIZATION = 0,
  PASTERIZATION = 1,
  CUSTOM = 2,
  ProcessConfigType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProcessConfigType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProcessConfigType_IsValid(int value);
constexpr ProcessConfigType ProcessConfigType_MIN = STERILIZATION;
constexpr ProcessConfigType ProcessConfigType_MAX = CUSTOM;
constexpr int ProcessConfigType_ARRAYSIZE = ProcessConfigType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigType_descriptor();
template<typename T>
inline const std::string& ProcessConfigType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessConfigType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessConfigType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessConfigType_descriptor(), enum_t_value);
}
inline bool ProcessConfigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessConfigType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessConfigType>(
    ProcessConfigType_descriptor(), name, value);
}
enum ProcessConfigState : int {
  READY = 0,
  STARTING = 1,
  FILLING = 2,
  HEATING = 3,
  COOLING = 4,
  FINISHING = 5,
  FINISHED = 6,
  ProcessConfigState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProcessConfigState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProcessConfigState_IsValid(int value);
constexpr ProcessConfigState ProcessConfigState_MIN = READY;
constexpr ProcessConfigState ProcessConfigState_MAX = FINISHED;
constexpr int ProcessConfigState_ARRAYSIZE = ProcessConfigState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigState_descriptor();
template<typename T>
inline const std::string& ProcessConfigState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessConfigState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessConfigState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessConfigState_descriptor(), enum_t_value);
}
inline bool ProcessConfigState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessConfigState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessConfigState>(
    ProcessConfigState_descriptor(), name, value);
}
enum ProcessConfigMode : int {
  TARGETF = 0,
  TIME = 1,
  ProcessConfigMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProcessConfigMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProcessConfigMode_IsValid(int value);
constexpr ProcessConfigMode ProcessConfigMode_MIN = TARGETF;
constexpr ProcessConfigMode ProcessConfigMode_MAX = TIME;
constexpr int ProcessConfigMode_ARRAYSIZE = ProcessConfigMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigMode_descriptor();
template<typename T>
inline const std::string& ProcessConfigMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessConfigMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessConfigMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessConfigMode_descriptor(), enum_t_value);
}
inline bool ProcessConfigMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessConfigMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessConfigMode>(
    ProcessConfigMode_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Autoklav.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Autoklav.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsStringFieldNumber = 3,
    kCodeFieldNumber = 1,
    kErrorsFieldNumber = 2,
  };
  // string errorsString = 3;
  void clear_errorsstring();
  const std::string& errorsstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errorsstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errorsstring();
  PROTOBUF_NODISCARD std::string* release_errorsstring();
  void set_allocated_errorsstring(std::string* errorsstring);
  private:
  const std::string& _internal_errorsstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errorsstring(const std::string& value);
  std::string* _internal_mutable_errorsstring();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // int32 errors = 2;
  void clear_errors();
  int32_t errors() const;
  void set_errors(int32_t value);
  private:
  int32_t _internal_errors() const;
  void _internal_set_errors(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errorsstring_;
    int32_t code_;
    int32_t errors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class Variables final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.Variables) */ {
 public:
  inline Variables() : Variables(nullptr) {}
  ~Variables() override;
  explicit PROTOBUF_CONSTEXPR Variables(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Variables(const Variables& from);
  Variables(Variables&& from) noexcept
    : Variables() {
    *this = ::std::move(from);
  }

  inline Variables& operator=(const Variables& from) {
    CopyFrom(from);
    return *this;
  }
  inline Variables& operator=(Variables&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Variables& default_instance() {
    return *internal_default_instance();
  }
  static inline const Variables* internal_default_instance() {
    return reinterpret_cast<const Variables*>(
               &_Variables_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Variables& a, Variables& b) {
    a.Swap(&b);
  }
  inline void Swap(Variables* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Variables* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Variables* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Variables>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Variables& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Variables& from) {
    Variables::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Variables* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.Variables";
  }
  protected:
  explicit Variables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetKFieldNumber = 1,
    kSerialDataTimeFieldNumber = 2,
    kStateMachineTickFieldNumber = 3,
    kSterilizationTempFieldNumber = 4,
    kPasterizationTempFieldNumber = 5,
  };
  // double targetK = 1;
  void clear_targetk();
  double targetk() const;
  void set_targetk(double value);
  private:
  double _internal_targetk() const;
  void _internal_set_targetk(double value);
  public:

  // int32 serialDataTime = 2;
  void clear_serialdatatime();
  int32_t serialdatatime() const;
  void set_serialdatatime(int32_t value);
  private:
  int32_t _internal_serialdatatime() const;
  void _internal_set_serialdatatime(int32_t value);
  public:

  // int32 stateMachineTick = 3;
  void clear_statemachinetick();
  int32_t statemachinetick() const;
  void set_statemachinetick(int32_t value);
  private:
  int32_t _internal_statemachinetick() const;
  void _internal_set_statemachinetick(int32_t value);
  public:

  // double sterilizationTemp = 4;
  void clear_sterilizationtemp();
  double sterilizationtemp() const;
  void set_sterilizationtemp(double value);
  private:
  double _internal_sterilizationtemp() const;
  void _internal_set_sterilizationtemp(double value);
  public:

  // double pasterizationTemp = 5;
  void clear_pasterizationtemp();
  double pasterizationtemp() const;
  void set_pasterizationtemp(double value);
  private:
  double _internal_pasterizationtemp() const;
  void _internal_set_pasterizationtemp(double value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.Variables)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double targetk_;
    int32_t serialdatatime_;
    int32_t statemachinetick_;
    double sterilizationtemp_;
    double pasterizationtemp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class SetVariable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.SetVariable) */ {
 public:
  inline SetVariable() : SetVariable(nullptr) {}
  ~SetVariable() override;
  explicit PROTOBUF_CONSTEXPR SetVariable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVariable(const SetVariable& from);
  SetVariable(SetVariable&& from) noexcept
    : SetVariable() {
    *this = ::std::move(from);
  }

  inline SetVariable& operator=(const SetVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVariable& operator=(SetVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVariable* internal_default_instance() {
    return reinterpret_cast<const SetVariable*>(
               &_SetVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetVariable& a, SetVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVariable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVariable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVariable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVariable& from) {
    SetVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVariable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.SetVariable";
  }
  protected:
  explicit SetVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.SetVariable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class SensorValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.SensorValues) */ {
 public:
  inline SensorValues() : SensorValues(nullptr) {}
  ~SensorValues() override;
  explicit PROTOBUF_CONSTEXPR SensorValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorValues(const SensorValues& from);
  SensorValues(SensorValues&& from) noexcept
    : SensorValues() {
    *this = ::std::move(from);
  }

  inline SensorValues& operator=(const SensorValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorValues& operator=(SensorValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorValues* internal_default_instance() {
    return reinterpret_cast<const SensorValues*>(
               &_SensorValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SensorValues& a, SensorValues& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorValues& from) {
    SensorValues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.SensorValues";
  }
  protected:
  explicit SensorValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempFieldNumber = 1,
    kTempKFieldNumber = 2,
    kPressureFieldNumber = 3,
  };
  // double temp = 1;
  void clear_temp();
  double temp() const;
  void set_temp(double value);
  private:
  double _internal_temp() const;
  void _internal_set_temp(double value);
  public:

  // double tempK = 2;
  void clear_tempk();
  double tempk() const;
  void set_tempk(double value);
  private:
  double _internal_tempk() const;
  void _internal_set_tempk(double value);
  public:

  // double pressure = 3;
  void clear_pressure();
  double pressure() const;
  void set_pressure(double value);
  private:
  double _internal_pressure() const;
  void _internal_set_pressure(double value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.SensorValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double temp_;
    double tempk_;
    double pressure_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class StateMachineValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.StateMachineValues) */ {
 public:
  inline StateMachineValues() : StateMachineValues(nullptr) {}
  ~StateMachineValues() override;
  explicit PROTOBUF_CONSTEXPR StateMachineValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateMachineValues(const StateMachineValues& from);
  StateMachineValues(StateMachineValues&& from) noexcept
    : StateMachineValues() {
    *this = ::std::move(from);
  }

  inline StateMachineValues& operator=(const StateMachineValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateMachineValues& operator=(StateMachineValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateMachineValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateMachineValues* internal_default_instance() {
    return reinterpret_cast<const StateMachineValues*>(
               &_StateMachineValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StateMachineValues& a, StateMachineValues& b) {
    a.Swap(&b);
  }
  inline void Swap(StateMachineValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateMachineValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateMachineValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateMachineValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateMachineValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateMachineValues& from) {
    StateMachineValues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateMachineValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.StateMachineValues";
  }
  protected:
  explicit StateMachineValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempFieldNumber = 2,
    kTempKFieldNumber = 3,
    kDTempFieldNumber = 4,
    kPressureFieldNumber = 5,
    kDrFieldNumber = 6,
    kFrFieldNumber = 7,
    kRFieldNumber = 8,
    kSumFrFieldNumber = 9,
    kSumrFieldNumber = 10,
    kTimeFieldNumber = 1,
  };
  // double temp = 2;
  void clear_temp();
  double temp() const;
  void set_temp(double value);
  private:
  double _internal_temp() const;
  void _internal_set_temp(double value);
  public:

  // double tempK = 3;
  void clear_tempk();
  double tempk() const;
  void set_tempk(double value);
  private:
  double _internal_tempk() const;
  void _internal_set_tempk(double value);
  public:

  // double dTemp = 4;
  void clear_dtemp();
  double dtemp() const;
  void set_dtemp(double value);
  private:
  double _internal_dtemp() const;
  void _internal_set_dtemp(double value);
  public:

  // double pressure = 5;
  void clear_pressure();
  double pressure() const;
  void set_pressure(double value);
  private:
  double _internal_pressure() const;
  void _internal_set_pressure(double value);
  public:

  // double Dr = 6;
  void clear_dr();
  double dr() const;
  void set_dr(double value);
  private:
  double _internal_dr() const;
  void _internal_set_dr(double value);
  public:

  // double Fr = 7;
  void clear_fr();
  double fr() const;
  void set_fr(double value);
  private:
  double _internal_fr() const;
  void _internal_set_fr(double value);
  public:

  // double r = 8;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double sumFr = 9;
  void clear_sumfr();
  double sumfr() const;
  void set_sumfr(double value);
  private:
  double _internal_sumfr() const;
  void _internal_set_sumfr(double value);
  public:

  // double sumr = 10;
  void clear_sumr();
  double sumr() const;
  void set_sumr(double value);
  private:
  double _internal_sumr() const;
  void _internal_set_sumr(double value);
  public:

  // uint32 time = 1;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.StateMachineValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double temp_;
    double tempk_;
    double dtemp_;
    double pressure_;
    double dr_;
    double fr_;
    double r_;
    double sumfr_;
    double sumr_;
    uint32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class ProcessConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.ProcessConfig) */ {
 public:
  inline ProcessConfig() : ProcessConfig(nullptr) {}
  ~ProcessConfig() override;
  explicit PROTOBUF_CONSTEXPR ProcessConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessConfig(const ProcessConfig& from);
  ProcessConfig(ProcessConfig&& from) noexcept
    : ProcessConfig() {
    *this = ::std::move(from);
  }

  inline ProcessConfig& operator=(const ProcessConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessConfig& operator=(ProcessConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessConfig* internal_default_instance() {
    return reinterpret_cast<const ProcessConfig*>(
               &_ProcessConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProcessConfig& a, ProcessConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessConfig& from) {
    ProcessConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.ProcessConfig";
  }
  protected:
  explicit ProcessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomTempFieldNumber = 2,
    kTypeFieldNumber = 1,
    kModeFieldNumber = 3,
    kTargetFFieldNumber = 4,
    kMaintainTempFieldNumber = 6,
    kMaintainPressureFieldNumber = 7,
    kFinishTempFieldNumber = 8,
    kTargetTimeFieldNumber = 5,
  };
  // double customTemp = 2;
  void clear_customtemp();
  double customtemp() const;
  void set_customtemp(double value);
  private:
  double _internal_customtemp() const;
  void _internal_set_customtemp(double value);
  public:

  // .Autoklav.ProcessConfigType type = 1;
  void clear_type();
  ::Autoklav::ProcessConfigType type() const;
  void set_type(::Autoklav::ProcessConfigType value);
  private:
  ::Autoklav::ProcessConfigType _internal_type() const;
  void _internal_set_type(::Autoklav::ProcessConfigType value);
  public:

  // .Autoklav.ProcessConfigMode mode = 3;
  void clear_mode();
  ::Autoklav::ProcessConfigMode mode() const;
  void set_mode(::Autoklav::ProcessConfigMode value);
  private:
  ::Autoklav::ProcessConfigMode _internal_mode() const;
  void _internal_set_mode(::Autoklav::ProcessConfigMode value);
  public:

  // double targetF = 4;
  void clear_targetf();
  double targetf() const;
  void set_targetf(double value);
  private:
  double _internal_targetf() const;
  void _internal_set_targetf(double value);
  public:

  // double maintainTemp = 6;
  void clear_maintaintemp();
  double maintaintemp() const;
  void set_maintaintemp(double value);
  private:
  double _internal_maintaintemp() const;
  void _internal_set_maintaintemp(double value);
  public:

  // double maintainPressure = 7;
  void clear_maintainpressure();
  double maintainpressure() const;
  void set_maintainpressure(double value);
  private:
  double _internal_maintainpressure() const;
  void _internal_set_maintainpressure(double value);
  public:

  // double finishTemp = 8;
  void clear_finishtemp();
  double finishtemp() const;
  void set_finishtemp(double value);
  private:
  double _internal_finishtemp() const;
  void _internal_set_finishtemp(double value);
  public:

  // uint32 targetTime = 5;
  void clear_targettime();
  uint32_t targettime() const;
  void set_targettime(uint32_t value);
  private:
  uint32_t _internal_targettime() const;
  void _internal_set_targettime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.ProcessConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double customtemp_;
    int type_;
    int mode_;
    double targetf_;
    double maintaintemp_;
    double maintainpressure_;
    double finishtemp_;
    uint32_t targettime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class ProcessInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.ProcessInfo) */ {
 public:
  inline ProcessInfo() : ProcessInfo(nullptr) {}
  ~ProcessInfo() override;
  explicit PROTOBUF_CONSTEXPR ProcessInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessInfo(const ProcessInfo& from);
  ProcessInfo(ProcessInfo&& from) noexcept
    : ProcessInfo() {
    *this = ::std::move(from);
  }

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessInfo& operator=(ProcessInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessInfo*>(
               &_ProcessInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProcessInfo& a, ProcessInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessInfo& from) {
    ProcessInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.ProcessInfo";
  }
  protected:
  explicit ProcessInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductNameFieldNumber = 1,
    kProductQuantityFieldNumber = 2,
    kBacteriaFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kProcessStartFieldNumber = 5,
    kProcessLengthFieldNumber = 6,
  };
  // string productName = 1;
  void clear_productname();
  const std::string& productname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productname();
  PROTOBUF_NODISCARD std::string* release_productname();
  void set_allocated_productname(std::string* productname);
  private:
  const std::string& _internal_productname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productname(const std::string& value);
  std::string* _internal_mutable_productname();
  public:

  // string productQuantity = 2;
  void clear_productquantity();
  const std::string& productquantity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productquantity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productquantity();
  PROTOBUF_NODISCARD std::string* release_productquantity();
  void set_allocated_productquantity(std::string* productquantity);
  private:
  const std::string& _internal_productquantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productquantity(const std::string& value);
  std::string* _internal_mutable_productquantity();
  public:

  // string bacteria = 3;
  void clear_bacteria();
  const std::string& bacteria() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bacteria(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bacteria();
  PROTOBUF_NODISCARD std::string* release_bacteria();
  void set_allocated_bacteria(std::string* bacteria);
  private:
  const std::string& _internal_bacteria() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bacteria(const std::string& value);
  std::string* _internal_mutable_bacteria();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string processStart = 5;
  void clear_processstart();
  const std::string& processstart() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processstart(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processstart();
  PROTOBUF_NODISCARD std::string* release_processstart();
  void set_allocated_processstart(std::string* processstart);
  private:
  const std::string& _internal_processstart() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processstart(const std::string& value);
  std::string* _internal_mutable_processstart();
  public:

  // string processLength = 6;
  void clear_processlength();
  const std::string& processlength() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processlength(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processlength();
  PROTOBUF_NODISCARD std::string* release_processlength();
  void set_allocated_processlength(std::string* processlength);
  private:
  const std::string& _internal_processlength() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processlength(const std::string& value);
  std::string* _internal_mutable_processlength();
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.ProcessInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productquantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bacteria_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processstart_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processlength_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class ProcessLogRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.ProcessLogRow) */ {
 public:
  inline ProcessLogRow() : ProcessLogRow(nullptr) {}
  ~ProcessLogRow() override;
  explicit PROTOBUF_CONSTEXPR ProcessLogRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessLogRow(const ProcessLogRow& from);
  ProcessLogRow(ProcessLogRow&& from) noexcept
    : ProcessLogRow() {
    *this = ::std::move(from);
  }

  inline ProcessLogRow& operator=(const ProcessLogRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessLogRow& operator=(ProcessLogRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessLogRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessLogRow* internal_default_instance() {
    return reinterpret_cast<const ProcessLogRow*>(
               &_ProcessLogRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProcessLogRow& a, ProcessLogRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessLogRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessLogRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessLogRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessLogRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessLogRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessLogRow& from) {
    ProcessLogRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessLogRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.ProcessLogRow";
  }
  protected:
  explicit ProcessLogRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductNameFieldNumber = 2,
    kProductQuantityFieldNumber = 3,
    kBacteriaFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kProcessStartFieldNumber = 6,
    kProcessLengthFieldNumber = 7,
    kIdFieldNumber = 1,
  };
  // string productName = 2;
  void clear_productname();
  const std::string& productname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productname();
  PROTOBUF_NODISCARD std::string* release_productname();
  void set_allocated_productname(std::string* productname);
  private:
  const std::string& _internal_productname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productname(const std::string& value);
  std::string* _internal_mutable_productname();
  public:

  // string productQuantity = 3;
  void clear_productquantity();
  const std::string& productquantity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productquantity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productquantity();
  PROTOBUF_NODISCARD std::string* release_productquantity();
  void set_allocated_productquantity(std::string* productquantity);
  private:
  const std::string& _internal_productquantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productquantity(const std::string& value);
  std::string* _internal_mutable_productquantity();
  public:

  // string bacteria = 4;
  void clear_bacteria();
  const std::string& bacteria() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bacteria(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bacteria();
  PROTOBUF_NODISCARD std::string* release_bacteria();
  void set_allocated_bacteria(std::string* bacteria);
  private:
  const std::string& _internal_bacteria() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bacteria(const std::string& value);
  std::string* _internal_mutable_bacteria();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string processStart = 6;
  void clear_processstart();
  const std::string& processstart() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processstart(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processstart();
  PROTOBUF_NODISCARD std::string* release_processstart();
  void set_allocated_processstart(std::string* processstart);
  private:
  const std::string& _internal_processstart() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processstart(const std::string& value);
  std::string* _internal_mutable_processstart();
  public:

  // string processLength = 7;
  void clear_processlength();
  const std::string& processlength() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processlength(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processlength();
  PROTOBUF_NODISCARD std::string* release_processlength();
  void set_allocated_processlength(std::string* processlength);
  private:
  const std::string& _internal_processlength() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processlength(const std::string& value);
  std::string* _internal_mutable_processlength();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Autoklav.ProcessLogRow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productquantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bacteria_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processstart_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processlength_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// -------------------------------------------------------------------

class StartProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Autoklav.StartProcessRequest) */ {
 public:
  inline StartProcessRequest() : StartProcessRequest(nullptr) {}
  ~StartProcessRequest() override;
  explicit PROTOBUF_CONSTEXPR StartProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartProcessRequest(const StartProcessRequest& from);
  StartProcessRequest(StartProcessRequest&& from) noexcept
    : StartProcessRequest() {
    *this = ::std::move(from);
  }

  inline StartProcessRequest& operator=(const StartProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartProcessRequest& operator=(StartProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartProcessRequest* internal_default_instance() {
    return reinterpret_cast<const StartProcessRequest*>(
               &_StartProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartProcessRequest& a, StartProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartProcessRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartProcessRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartProcessRequest& from) {
    StartProcessRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartProcessRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Autoklav.StartProcessRequest";
  }
  protected:
  explicit StartProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessConfigFieldNumber = 1,
    kProcessInfoFieldNumber = 2,
  };
  // .Autoklav.ProcessConfig processConfig = 1;
  bool has_processconfig() const;
  private:
  bool _internal_has_processconfig() const;
  public:
  void clear_processconfig();
  const ::Autoklav::ProcessConfig& processconfig() const;
  PROTOBUF_NODISCARD ::Autoklav::ProcessConfig* release_processconfig();
  ::Autoklav::ProcessConfig* mutable_processconfig();
  void set_allocated_processconfig(::Autoklav::ProcessConfig* processconfig);
  private:
  const ::Autoklav::ProcessConfig& _internal_processconfig() const;
  ::Autoklav::ProcessConfig* _internal_mutable_processconfig();
  public:
  void unsafe_arena_set_allocated_processconfig(
      ::Autoklav::ProcessConfig* processconfig);
  ::Autoklav::ProcessConfig* unsafe_arena_release_processconfig();

  // .Autoklav.ProcessInfo processInfo = 2;
  bool has_processinfo() const;
  private:
  bool _internal_has_processinfo() const;
  public:
  void clear_processinfo();
  const ::Autoklav::ProcessInfo& processinfo() const;
  PROTOBUF_NODISCARD ::Autoklav::ProcessInfo* release_processinfo();
  ::Autoklav::ProcessInfo* mutable_processinfo();
  void set_allocated_processinfo(::Autoklav::ProcessInfo* processinfo);
  private:
  const ::Autoklav::ProcessInfo& _internal_processinfo() const;
  ::Autoklav::ProcessInfo* _internal_mutable_processinfo();
  public:
  void unsafe_arena_set_allocated_processinfo(
      ::Autoklav::ProcessInfo* processinfo);
  ::Autoklav::ProcessInfo* unsafe_arena_release_processinfo();

  // @@protoc_insertion_point(class_scope:Autoklav.StartProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Autoklav::ProcessConfig* processconfig_;
    ::Autoklav::ProcessInfo* processinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autoklav_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Status

// int32 code = 1;
inline void Status::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t Status::_internal_code() const {
  return _impl_.code_;
}
inline int32_t Status::code() const {
  // @@protoc_insertion_point(field_get:Autoklav.Status.code)
  return _internal_code();
}
inline void Status::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void Status::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:Autoklav.Status.code)
}

// int32 errors = 2;
inline void Status::clear_errors() {
  _impl_.errors_ = 0;
}
inline int32_t Status::_internal_errors() const {
  return _impl_.errors_;
}
inline int32_t Status::errors() const {
  // @@protoc_insertion_point(field_get:Autoklav.Status.errors)
  return _internal_errors();
}
inline void Status::_internal_set_errors(int32_t value) {
  
  _impl_.errors_ = value;
}
inline void Status::set_errors(int32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:Autoklav.Status.errors)
}

// string errorsString = 3;
inline void Status::clear_errorsstring() {
  _impl_.errorsstring_.ClearToEmpty();
}
inline const std::string& Status::errorsstring() const {
  // @@protoc_insertion_point(field_get:Autoklav.Status.errorsString)
  return _internal_errorsstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_errorsstring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errorsstring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.Status.errorsString)
}
inline std::string* Status::mutable_errorsstring() {
  std::string* _s = _internal_mutable_errorsstring();
  // @@protoc_insertion_point(field_mutable:Autoklav.Status.errorsString)
  return _s;
}
inline const std::string& Status::_internal_errorsstring() const {
  return _impl_.errorsstring_.Get();
}
inline void Status::_internal_set_errorsstring(const std::string& value) {
  
  _impl_.errorsstring_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_errorsstring() {
  
  return _impl_.errorsstring_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_errorsstring() {
  // @@protoc_insertion_point(field_release:Autoklav.Status.errorsString)
  return _impl_.errorsstring_.Release();
}
inline void Status::set_allocated_errorsstring(std::string* errorsstring) {
  if (errorsstring != nullptr) {
    
  } else {
    
  }
  _impl_.errorsstring_.SetAllocated(errorsstring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errorsstring_.IsDefault()) {
    _impl_.errorsstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.Status.errorsString)
}

// -------------------------------------------------------------------

// Variables

// double targetK = 1;
inline void Variables::clear_targetk() {
  _impl_.targetk_ = 0;
}
inline double Variables::_internal_targetk() const {
  return _impl_.targetk_;
}
inline double Variables::targetk() const {
  // @@protoc_insertion_point(field_get:Autoklav.Variables.targetK)
  return _internal_targetk();
}
inline void Variables::_internal_set_targetk(double value) {
  
  _impl_.targetk_ = value;
}
inline void Variables::set_targetk(double value) {
  _internal_set_targetk(value);
  // @@protoc_insertion_point(field_set:Autoklav.Variables.targetK)
}

// int32 serialDataTime = 2;
inline void Variables::clear_serialdatatime() {
  _impl_.serialdatatime_ = 0;
}
inline int32_t Variables::_internal_serialdatatime() const {
  return _impl_.serialdatatime_;
}
inline int32_t Variables::serialdatatime() const {
  // @@protoc_insertion_point(field_get:Autoklav.Variables.serialDataTime)
  return _internal_serialdatatime();
}
inline void Variables::_internal_set_serialdatatime(int32_t value) {
  
  _impl_.serialdatatime_ = value;
}
inline void Variables::set_serialdatatime(int32_t value) {
  _internal_set_serialdatatime(value);
  // @@protoc_insertion_point(field_set:Autoklav.Variables.serialDataTime)
}

// int32 stateMachineTick = 3;
inline void Variables::clear_statemachinetick() {
  _impl_.statemachinetick_ = 0;
}
inline int32_t Variables::_internal_statemachinetick() const {
  return _impl_.statemachinetick_;
}
inline int32_t Variables::statemachinetick() const {
  // @@protoc_insertion_point(field_get:Autoklav.Variables.stateMachineTick)
  return _internal_statemachinetick();
}
inline void Variables::_internal_set_statemachinetick(int32_t value) {
  
  _impl_.statemachinetick_ = value;
}
inline void Variables::set_statemachinetick(int32_t value) {
  _internal_set_statemachinetick(value);
  // @@protoc_insertion_point(field_set:Autoklav.Variables.stateMachineTick)
}

// double sterilizationTemp = 4;
inline void Variables::clear_sterilizationtemp() {
  _impl_.sterilizationtemp_ = 0;
}
inline double Variables::_internal_sterilizationtemp() const {
  return _impl_.sterilizationtemp_;
}
inline double Variables::sterilizationtemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.Variables.sterilizationTemp)
  return _internal_sterilizationtemp();
}
inline void Variables::_internal_set_sterilizationtemp(double value) {
  
  _impl_.sterilizationtemp_ = value;
}
inline void Variables::set_sterilizationtemp(double value) {
  _internal_set_sterilizationtemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.Variables.sterilizationTemp)
}

// double pasterizationTemp = 5;
inline void Variables::clear_pasterizationtemp() {
  _impl_.pasterizationtemp_ = 0;
}
inline double Variables::_internal_pasterizationtemp() const {
  return _impl_.pasterizationtemp_;
}
inline double Variables::pasterizationtemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.Variables.pasterizationTemp)
  return _internal_pasterizationtemp();
}
inline void Variables::_internal_set_pasterizationtemp(double value) {
  
  _impl_.pasterizationtemp_ = value;
}
inline void Variables::set_pasterizationtemp(double value) {
  _internal_set_pasterizationtemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.Variables.pasterizationTemp)
}

// -------------------------------------------------------------------

// SetVariable

// string name = 1;
inline void SetVariable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SetVariable::name() const {
  // @@protoc_insertion_point(field_get:Autoklav.SetVariable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetVariable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.SetVariable.name)
}
inline std::string* SetVariable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Autoklav.SetVariable.name)
  return _s;
}
inline const std::string& SetVariable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SetVariable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetVariable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetVariable::release_name() {
  // @@protoc_insertion_point(field_release:Autoklav.SetVariable.name)
  return _impl_.name_.Release();
}
inline void SetVariable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.SetVariable.name)
}

// string value = 2;
inline void SetVariable::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetVariable::value() const {
  // @@protoc_insertion_point(field_get:Autoklav.SetVariable.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetVariable::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.SetVariable.value)
}
inline std::string* SetVariable::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Autoklav.SetVariable.value)
  return _s;
}
inline const std::string& SetVariable::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetVariable::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetVariable::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetVariable::release_value() {
  // @@protoc_insertion_point(field_release:Autoklav.SetVariable.value)
  return _impl_.value_.Release();
}
inline void SetVariable::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.SetVariable.value)
}

// -------------------------------------------------------------------

// SensorValues

// double temp = 1;
inline void SensorValues::clear_temp() {
  _impl_.temp_ = 0;
}
inline double SensorValues::_internal_temp() const {
  return _impl_.temp_;
}
inline double SensorValues::temp() const {
  // @@protoc_insertion_point(field_get:Autoklav.SensorValues.temp)
  return _internal_temp();
}
inline void SensorValues::_internal_set_temp(double value) {
  
  _impl_.temp_ = value;
}
inline void SensorValues::set_temp(double value) {
  _internal_set_temp(value);
  // @@protoc_insertion_point(field_set:Autoklav.SensorValues.temp)
}

// double tempK = 2;
inline void SensorValues::clear_tempk() {
  _impl_.tempk_ = 0;
}
inline double SensorValues::_internal_tempk() const {
  return _impl_.tempk_;
}
inline double SensorValues::tempk() const {
  // @@protoc_insertion_point(field_get:Autoklav.SensorValues.tempK)
  return _internal_tempk();
}
inline void SensorValues::_internal_set_tempk(double value) {
  
  _impl_.tempk_ = value;
}
inline void SensorValues::set_tempk(double value) {
  _internal_set_tempk(value);
  // @@protoc_insertion_point(field_set:Autoklav.SensorValues.tempK)
}

// double pressure = 3;
inline void SensorValues::clear_pressure() {
  _impl_.pressure_ = 0;
}
inline double SensorValues::_internal_pressure() const {
  return _impl_.pressure_;
}
inline double SensorValues::pressure() const {
  // @@protoc_insertion_point(field_get:Autoklav.SensorValues.pressure)
  return _internal_pressure();
}
inline void SensorValues::_internal_set_pressure(double value) {
  
  _impl_.pressure_ = value;
}
inline void SensorValues::set_pressure(double value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:Autoklav.SensorValues.pressure)
}

// -------------------------------------------------------------------

// StateMachineValues

// uint32 time = 1;
inline void StateMachineValues::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t StateMachineValues::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t StateMachineValues::time() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.time)
  return _internal_time();
}
inline void StateMachineValues::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void StateMachineValues::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.time)
}

// double temp = 2;
inline void StateMachineValues::clear_temp() {
  _impl_.temp_ = 0;
}
inline double StateMachineValues::_internal_temp() const {
  return _impl_.temp_;
}
inline double StateMachineValues::temp() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.temp)
  return _internal_temp();
}
inline void StateMachineValues::_internal_set_temp(double value) {
  
  _impl_.temp_ = value;
}
inline void StateMachineValues::set_temp(double value) {
  _internal_set_temp(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.temp)
}

// double tempK = 3;
inline void StateMachineValues::clear_tempk() {
  _impl_.tempk_ = 0;
}
inline double StateMachineValues::_internal_tempk() const {
  return _impl_.tempk_;
}
inline double StateMachineValues::tempk() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.tempK)
  return _internal_tempk();
}
inline void StateMachineValues::_internal_set_tempk(double value) {
  
  _impl_.tempk_ = value;
}
inline void StateMachineValues::set_tempk(double value) {
  _internal_set_tempk(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.tempK)
}

// double dTemp = 4;
inline void StateMachineValues::clear_dtemp() {
  _impl_.dtemp_ = 0;
}
inline double StateMachineValues::_internal_dtemp() const {
  return _impl_.dtemp_;
}
inline double StateMachineValues::dtemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.dTemp)
  return _internal_dtemp();
}
inline void StateMachineValues::_internal_set_dtemp(double value) {
  
  _impl_.dtemp_ = value;
}
inline void StateMachineValues::set_dtemp(double value) {
  _internal_set_dtemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.dTemp)
}

// double pressure = 5;
inline void StateMachineValues::clear_pressure() {
  _impl_.pressure_ = 0;
}
inline double StateMachineValues::_internal_pressure() const {
  return _impl_.pressure_;
}
inline double StateMachineValues::pressure() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.pressure)
  return _internal_pressure();
}
inline void StateMachineValues::_internal_set_pressure(double value) {
  
  _impl_.pressure_ = value;
}
inline void StateMachineValues::set_pressure(double value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.pressure)
}

// double Dr = 6;
inline void StateMachineValues::clear_dr() {
  _impl_.dr_ = 0;
}
inline double StateMachineValues::_internal_dr() const {
  return _impl_.dr_;
}
inline double StateMachineValues::dr() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.Dr)
  return _internal_dr();
}
inline void StateMachineValues::_internal_set_dr(double value) {
  
  _impl_.dr_ = value;
}
inline void StateMachineValues::set_dr(double value) {
  _internal_set_dr(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.Dr)
}

// double Fr = 7;
inline void StateMachineValues::clear_fr() {
  _impl_.fr_ = 0;
}
inline double StateMachineValues::_internal_fr() const {
  return _impl_.fr_;
}
inline double StateMachineValues::fr() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.Fr)
  return _internal_fr();
}
inline void StateMachineValues::_internal_set_fr(double value) {
  
  _impl_.fr_ = value;
}
inline void StateMachineValues::set_fr(double value) {
  _internal_set_fr(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.Fr)
}

// double r = 8;
inline void StateMachineValues::clear_r() {
  _impl_.r_ = 0;
}
inline double StateMachineValues::_internal_r() const {
  return _impl_.r_;
}
inline double StateMachineValues::r() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.r)
  return _internal_r();
}
inline void StateMachineValues::_internal_set_r(double value) {
  
  _impl_.r_ = value;
}
inline void StateMachineValues::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.r)
}

// double sumFr = 9;
inline void StateMachineValues::clear_sumfr() {
  _impl_.sumfr_ = 0;
}
inline double StateMachineValues::_internal_sumfr() const {
  return _impl_.sumfr_;
}
inline double StateMachineValues::sumfr() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.sumFr)
  return _internal_sumfr();
}
inline void StateMachineValues::_internal_set_sumfr(double value) {
  
  _impl_.sumfr_ = value;
}
inline void StateMachineValues::set_sumfr(double value) {
  _internal_set_sumfr(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.sumFr)
}

// double sumr = 10;
inline void StateMachineValues::clear_sumr() {
  _impl_.sumr_ = 0;
}
inline double StateMachineValues::_internal_sumr() const {
  return _impl_.sumr_;
}
inline double StateMachineValues::sumr() const {
  // @@protoc_insertion_point(field_get:Autoklav.StateMachineValues.sumr)
  return _internal_sumr();
}
inline void StateMachineValues::_internal_set_sumr(double value) {
  
  _impl_.sumr_ = value;
}
inline void StateMachineValues::set_sumr(double value) {
  _internal_set_sumr(value);
  // @@protoc_insertion_point(field_set:Autoklav.StateMachineValues.sumr)
}

// -------------------------------------------------------------------

// ProcessConfig

// .Autoklav.ProcessConfigType type = 1;
inline void ProcessConfig::clear_type() {
  _impl_.type_ = 0;
}
inline ::Autoklav::ProcessConfigType ProcessConfig::_internal_type() const {
  return static_cast< ::Autoklav::ProcessConfigType >(_impl_.type_);
}
inline ::Autoklav::ProcessConfigType ProcessConfig::type() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.type)
  return _internal_type();
}
inline void ProcessConfig::_internal_set_type(::Autoklav::ProcessConfigType value) {
  
  _impl_.type_ = value;
}
inline void ProcessConfig::set_type(::Autoklav::ProcessConfigType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.type)
}

// double customTemp = 2;
inline void ProcessConfig::clear_customtemp() {
  _impl_.customtemp_ = 0;
}
inline double ProcessConfig::_internal_customtemp() const {
  return _impl_.customtemp_;
}
inline double ProcessConfig::customtemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.customTemp)
  return _internal_customtemp();
}
inline void ProcessConfig::_internal_set_customtemp(double value) {
  
  _impl_.customtemp_ = value;
}
inline void ProcessConfig::set_customtemp(double value) {
  _internal_set_customtemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.customTemp)
}

// .Autoklav.ProcessConfigMode mode = 3;
inline void ProcessConfig::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::Autoklav::ProcessConfigMode ProcessConfig::_internal_mode() const {
  return static_cast< ::Autoklav::ProcessConfigMode >(_impl_.mode_);
}
inline ::Autoklav::ProcessConfigMode ProcessConfig::mode() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.mode)
  return _internal_mode();
}
inline void ProcessConfig::_internal_set_mode(::Autoklav::ProcessConfigMode value) {
  
  _impl_.mode_ = value;
}
inline void ProcessConfig::set_mode(::Autoklav::ProcessConfigMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.mode)
}

// double targetF = 4;
inline void ProcessConfig::clear_targetf() {
  _impl_.targetf_ = 0;
}
inline double ProcessConfig::_internal_targetf() const {
  return _impl_.targetf_;
}
inline double ProcessConfig::targetf() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.targetF)
  return _internal_targetf();
}
inline void ProcessConfig::_internal_set_targetf(double value) {
  
  _impl_.targetf_ = value;
}
inline void ProcessConfig::set_targetf(double value) {
  _internal_set_targetf(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.targetF)
}

// uint32 targetTime = 5;
inline void ProcessConfig::clear_targettime() {
  _impl_.targettime_ = 0u;
}
inline uint32_t ProcessConfig::_internal_targettime() const {
  return _impl_.targettime_;
}
inline uint32_t ProcessConfig::targettime() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.targetTime)
  return _internal_targettime();
}
inline void ProcessConfig::_internal_set_targettime(uint32_t value) {
  
  _impl_.targettime_ = value;
}
inline void ProcessConfig::set_targettime(uint32_t value) {
  _internal_set_targettime(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.targetTime)
}

// double maintainTemp = 6;
inline void ProcessConfig::clear_maintaintemp() {
  _impl_.maintaintemp_ = 0;
}
inline double ProcessConfig::_internal_maintaintemp() const {
  return _impl_.maintaintemp_;
}
inline double ProcessConfig::maintaintemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.maintainTemp)
  return _internal_maintaintemp();
}
inline void ProcessConfig::_internal_set_maintaintemp(double value) {
  
  _impl_.maintaintemp_ = value;
}
inline void ProcessConfig::set_maintaintemp(double value) {
  _internal_set_maintaintemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.maintainTemp)
}

// double maintainPressure = 7;
inline void ProcessConfig::clear_maintainpressure() {
  _impl_.maintainpressure_ = 0;
}
inline double ProcessConfig::_internal_maintainpressure() const {
  return _impl_.maintainpressure_;
}
inline double ProcessConfig::maintainpressure() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.maintainPressure)
  return _internal_maintainpressure();
}
inline void ProcessConfig::_internal_set_maintainpressure(double value) {
  
  _impl_.maintainpressure_ = value;
}
inline void ProcessConfig::set_maintainpressure(double value) {
  _internal_set_maintainpressure(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.maintainPressure)
}

// double finishTemp = 8;
inline void ProcessConfig::clear_finishtemp() {
  _impl_.finishtemp_ = 0;
}
inline double ProcessConfig::_internal_finishtemp() const {
  return _impl_.finishtemp_;
}
inline double ProcessConfig::finishtemp() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessConfig.finishTemp)
  return _internal_finishtemp();
}
inline void ProcessConfig::_internal_set_finishtemp(double value) {
  
  _impl_.finishtemp_ = value;
}
inline void ProcessConfig::set_finishtemp(double value) {
  _internal_set_finishtemp(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessConfig.finishTemp)
}

// -------------------------------------------------------------------

// ProcessInfo

// string productName = 1;
inline void ProcessInfo::clear_productname() {
  _impl_.productname_.ClearToEmpty();
}
inline const std::string& ProcessInfo::productname() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.productName)
  return _internal_productname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_productname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.productname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.productName)
}
inline std::string* ProcessInfo::mutable_productname() {
  std::string* _s = _internal_mutable_productname();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.productName)
  return _s;
}
inline const std::string& ProcessInfo::_internal_productname() const {
  return _impl_.productname_.Get();
}
inline void ProcessInfo::_internal_set_productname(const std::string& value) {
  
  _impl_.productname_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_productname() {
  
  return _impl_.productname_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_productname() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.productName)
  return _impl_.productname_.Release();
}
inline void ProcessInfo::set_allocated_productname(std::string* productname) {
  if (productname != nullptr) {
    
  } else {
    
  }
  _impl_.productname_.SetAllocated(productname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productname_.IsDefault()) {
    _impl_.productname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.productName)
}

// string productQuantity = 2;
inline void ProcessInfo::clear_productquantity() {
  _impl_.productquantity_.ClearToEmpty();
}
inline const std::string& ProcessInfo::productquantity() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.productQuantity)
  return _internal_productquantity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_productquantity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.productquantity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.productQuantity)
}
inline std::string* ProcessInfo::mutable_productquantity() {
  std::string* _s = _internal_mutable_productquantity();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.productQuantity)
  return _s;
}
inline const std::string& ProcessInfo::_internal_productquantity() const {
  return _impl_.productquantity_.Get();
}
inline void ProcessInfo::_internal_set_productquantity(const std::string& value) {
  
  _impl_.productquantity_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_productquantity() {
  
  return _impl_.productquantity_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_productquantity() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.productQuantity)
  return _impl_.productquantity_.Release();
}
inline void ProcessInfo::set_allocated_productquantity(std::string* productquantity) {
  if (productquantity != nullptr) {
    
  } else {
    
  }
  _impl_.productquantity_.SetAllocated(productquantity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productquantity_.IsDefault()) {
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.productQuantity)
}

// string bacteria = 3;
inline void ProcessInfo::clear_bacteria() {
  _impl_.bacteria_.ClearToEmpty();
}
inline const std::string& ProcessInfo::bacteria() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.bacteria)
  return _internal_bacteria();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_bacteria(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bacteria_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.bacteria)
}
inline std::string* ProcessInfo::mutable_bacteria() {
  std::string* _s = _internal_mutable_bacteria();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.bacteria)
  return _s;
}
inline const std::string& ProcessInfo::_internal_bacteria() const {
  return _impl_.bacteria_.Get();
}
inline void ProcessInfo::_internal_set_bacteria(const std::string& value) {
  
  _impl_.bacteria_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_bacteria() {
  
  return _impl_.bacteria_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_bacteria() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.bacteria)
  return _impl_.bacteria_.Release();
}
inline void ProcessInfo::set_allocated_bacteria(std::string* bacteria) {
  if (bacteria != nullptr) {
    
  } else {
    
  }
  _impl_.bacteria_.SetAllocated(bacteria, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bacteria_.IsDefault()) {
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.bacteria)
}

// string description = 4;
inline void ProcessInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ProcessInfo::description() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.description)
}
inline std::string* ProcessInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.description)
  return _s;
}
inline const std::string& ProcessInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ProcessInfo::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_description() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.description)
  return _impl_.description_.Release();
}
inline void ProcessInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.description)
}

// string processStart = 5;
inline void ProcessInfo::clear_processstart() {
  _impl_.processstart_.ClearToEmpty();
}
inline const std::string& ProcessInfo::processstart() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.processStart)
  return _internal_processstart();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_processstart(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processstart_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.processStart)
}
inline std::string* ProcessInfo::mutable_processstart() {
  std::string* _s = _internal_mutable_processstart();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.processStart)
  return _s;
}
inline const std::string& ProcessInfo::_internal_processstart() const {
  return _impl_.processstart_.Get();
}
inline void ProcessInfo::_internal_set_processstart(const std::string& value) {
  
  _impl_.processstart_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_processstart() {
  
  return _impl_.processstart_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_processstart() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.processStart)
  return _impl_.processstart_.Release();
}
inline void ProcessInfo::set_allocated_processstart(std::string* processstart) {
  if (processstart != nullptr) {
    
  } else {
    
  }
  _impl_.processstart_.SetAllocated(processstart, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processstart_.IsDefault()) {
    _impl_.processstart_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.processStart)
}

// string processLength = 6;
inline void ProcessInfo::clear_processlength() {
  _impl_.processlength_.ClearToEmpty();
}
inline const std::string& ProcessInfo::processlength() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessInfo.processLength)
  return _internal_processlength();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_processlength(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processlength_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessInfo.processLength)
}
inline std::string* ProcessInfo::mutable_processlength() {
  std::string* _s = _internal_mutable_processlength();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessInfo.processLength)
  return _s;
}
inline const std::string& ProcessInfo::_internal_processlength() const {
  return _impl_.processlength_.Get();
}
inline void ProcessInfo::_internal_set_processlength(const std::string& value) {
  
  _impl_.processlength_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_processlength() {
  
  return _impl_.processlength_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_processlength() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessInfo.processLength)
  return _impl_.processlength_.Release();
}
inline void ProcessInfo::set_allocated_processlength(std::string* processlength) {
  if (processlength != nullptr) {
    
  } else {
    
  }
  _impl_.processlength_.SetAllocated(processlength, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processlength_.IsDefault()) {
    _impl_.processlength_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessInfo.processLength)
}

// -------------------------------------------------------------------

// ProcessLogRow

// int32 id = 1;
inline void ProcessLogRow::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t ProcessLogRow::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ProcessLogRow::id() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.id)
  return _internal_id();
}
inline void ProcessLogRow::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void ProcessLogRow::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.id)
}

// string productName = 2;
inline void ProcessLogRow::clear_productname() {
  _impl_.productname_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::productname() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.productName)
  return _internal_productname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_productname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.productname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.productName)
}
inline std::string* ProcessLogRow::mutable_productname() {
  std::string* _s = _internal_mutable_productname();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.productName)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_productname() const {
  return _impl_.productname_.Get();
}
inline void ProcessLogRow::_internal_set_productname(const std::string& value) {
  
  _impl_.productname_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_productname() {
  
  return _impl_.productname_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_productname() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.productName)
  return _impl_.productname_.Release();
}
inline void ProcessLogRow::set_allocated_productname(std::string* productname) {
  if (productname != nullptr) {
    
  } else {
    
  }
  _impl_.productname_.SetAllocated(productname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productname_.IsDefault()) {
    _impl_.productname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.productName)
}

// string productQuantity = 3;
inline void ProcessLogRow::clear_productquantity() {
  _impl_.productquantity_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::productquantity() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.productQuantity)
  return _internal_productquantity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_productquantity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.productquantity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.productQuantity)
}
inline std::string* ProcessLogRow::mutable_productquantity() {
  std::string* _s = _internal_mutable_productquantity();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.productQuantity)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_productquantity() const {
  return _impl_.productquantity_.Get();
}
inline void ProcessLogRow::_internal_set_productquantity(const std::string& value) {
  
  _impl_.productquantity_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_productquantity() {
  
  return _impl_.productquantity_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_productquantity() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.productQuantity)
  return _impl_.productquantity_.Release();
}
inline void ProcessLogRow::set_allocated_productquantity(std::string* productquantity) {
  if (productquantity != nullptr) {
    
  } else {
    
  }
  _impl_.productquantity_.SetAllocated(productquantity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productquantity_.IsDefault()) {
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.productQuantity)
}

// string bacteria = 4;
inline void ProcessLogRow::clear_bacteria() {
  _impl_.bacteria_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::bacteria() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.bacteria)
  return _internal_bacteria();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_bacteria(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bacteria_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.bacteria)
}
inline std::string* ProcessLogRow::mutable_bacteria() {
  std::string* _s = _internal_mutable_bacteria();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.bacteria)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_bacteria() const {
  return _impl_.bacteria_.Get();
}
inline void ProcessLogRow::_internal_set_bacteria(const std::string& value) {
  
  _impl_.bacteria_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_bacteria() {
  
  return _impl_.bacteria_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_bacteria() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.bacteria)
  return _impl_.bacteria_.Release();
}
inline void ProcessLogRow::set_allocated_bacteria(std::string* bacteria) {
  if (bacteria != nullptr) {
    
  } else {
    
  }
  _impl_.bacteria_.SetAllocated(bacteria, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bacteria_.IsDefault()) {
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.bacteria)
}

// string description = 5;
inline void ProcessLogRow::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::description() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.description)
}
inline std::string* ProcessLogRow::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.description)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ProcessLogRow::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_description() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.description)
  return _impl_.description_.Release();
}
inline void ProcessLogRow::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.description)
}

// string processStart = 6;
inline void ProcessLogRow::clear_processstart() {
  _impl_.processstart_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::processstart() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.processStart)
  return _internal_processstart();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_processstart(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processstart_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.processStart)
}
inline std::string* ProcessLogRow::mutable_processstart() {
  std::string* _s = _internal_mutable_processstart();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.processStart)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_processstart() const {
  return _impl_.processstart_.Get();
}
inline void ProcessLogRow::_internal_set_processstart(const std::string& value) {
  
  _impl_.processstart_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_processstart() {
  
  return _impl_.processstart_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_processstart() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.processStart)
  return _impl_.processstart_.Release();
}
inline void ProcessLogRow::set_allocated_processstart(std::string* processstart) {
  if (processstart != nullptr) {
    
  } else {
    
  }
  _impl_.processstart_.SetAllocated(processstart, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processstart_.IsDefault()) {
    _impl_.processstart_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.processStart)
}

// string processLength = 7;
inline void ProcessLogRow::clear_processlength() {
  _impl_.processlength_.ClearToEmpty();
}
inline const std::string& ProcessLogRow::processlength() const {
  // @@protoc_insertion_point(field_get:Autoklav.ProcessLogRow.processLength)
  return _internal_processlength();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessLogRow::set_processlength(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processlength_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Autoklav.ProcessLogRow.processLength)
}
inline std::string* ProcessLogRow::mutable_processlength() {
  std::string* _s = _internal_mutable_processlength();
  // @@protoc_insertion_point(field_mutable:Autoklav.ProcessLogRow.processLength)
  return _s;
}
inline const std::string& ProcessLogRow::_internal_processlength() const {
  return _impl_.processlength_.Get();
}
inline void ProcessLogRow::_internal_set_processlength(const std::string& value) {
  
  _impl_.processlength_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessLogRow::_internal_mutable_processlength() {
  
  return _impl_.processlength_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessLogRow::release_processlength() {
  // @@protoc_insertion_point(field_release:Autoklav.ProcessLogRow.processLength)
  return _impl_.processlength_.Release();
}
inline void ProcessLogRow::set_allocated_processlength(std::string* processlength) {
  if (processlength != nullptr) {
    
  } else {
    
  }
  _impl_.processlength_.SetAllocated(processlength, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processlength_.IsDefault()) {
    _impl_.processlength_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Autoklav.ProcessLogRow.processLength)
}

// -------------------------------------------------------------------

// StartProcessRequest

// .Autoklav.ProcessConfig processConfig = 1;
inline bool StartProcessRequest::_internal_has_processconfig() const {
  return this != internal_default_instance() && _impl_.processconfig_ != nullptr;
}
inline bool StartProcessRequest::has_processconfig() const {
  return _internal_has_processconfig();
}
inline void StartProcessRequest::clear_processconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.processconfig_ != nullptr) {
    delete _impl_.processconfig_;
  }
  _impl_.processconfig_ = nullptr;
}
inline const ::Autoklav::ProcessConfig& StartProcessRequest::_internal_processconfig() const {
  const ::Autoklav::ProcessConfig* p = _impl_.processconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::Autoklav::ProcessConfig&>(
      ::Autoklav::_ProcessConfig_default_instance_);
}
inline const ::Autoklav::ProcessConfig& StartProcessRequest::processconfig() const {
  // @@protoc_insertion_point(field_get:Autoklav.StartProcessRequest.processConfig)
  return _internal_processconfig();
}
inline void StartProcessRequest::unsafe_arena_set_allocated_processconfig(
    ::Autoklav::ProcessConfig* processconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processconfig_);
  }
  _impl_.processconfig_ = processconfig;
  if (processconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Autoklav.StartProcessRequest.processConfig)
}
inline ::Autoklav::ProcessConfig* StartProcessRequest::release_processconfig() {
  
  ::Autoklav::ProcessConfig* temp = _impl_.processconfig_;
  _impl_.processconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Autoklav::ProcessConfig* StartProcessRequest::unsafe_arena_release_processconfig() {
  // @@protoc_insertion_point(field_release:Autoklav.StartProcessRequest.processConfig)
  
  ::Autoklav::ProcessConfig* temp = _impl_.processconfig_;
  _impl_.processconfig_ = nullptr;
  return temp;
}
inline ::Autoklav::ProcessConfig* StartProcessRequest::_internal_mutable_processconfig() {
  
  if (_impl_.processconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::Autoklav::ProcessConfig>(GetArenaForAllocation());
    _impl_.processconfig_ = p;
  }
  return _impl_.processconfig_;
}
inline ::Autoklav::ProcessConfig* StartProcessRequest::mutable_processconfig() {
  ::Autoklav::ProcessConfig* _msg = _internal_mutable_processconfig();
  // @@protoc_insertion_point(field_mutable:Autoklav.StartProcessRequest.processConfig)
  return _msg;
}
inline void StartProcessRequest::set_allocated_processconfig(::Autoklav::ProcessConfig* processconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processconfig_;
  }
  if (processconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processconfig);
    if (message_arena != submessage_arena) {
      processconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processconfig_ = processconfig;
  // @@protoc_insertion_point(field_set_allocated:Autoklav.StartProcessRequest.processConfig)
}

// .Autoklav.ProcessInfo processInfo = 2;
inline bool StartProcessRequest::_internal_has_processinfo() const {
  return this != internal_default_instance() && _impl_.processinfo_ != nullptr;
}
inline bool StartProcessRequest::has_processinfo() const {
  return _internal_has_processinfo();
}
inline void StartProcessRequest::clear_processinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.processinfo_ != nullptr) {
    delete _impl_.processinfo_;
  }
  _impl_.processinfo_ = nullptr;
}
inline const ::Autoklav::ProcessInfo& StartProcessRequest::_internal_processinfo() const {
  const ::Autoklav::ProcessInfo* p = _impl_.processinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Autoklav::ProcessInfo&>(
      ::Autoklav::_ProcessInfo_default_instance_);
}
inline const ::Autoklav::ProcessInfo& StartProcessRequest::processinfo() const {
  // @@protoc_insertion_point(field_get:Autoklav.StartProcessRequest.processInfo)
  return _internal_processinfo();
}
inline void StartProcessRequest::unsafe_arena_set_allocated_processinfo(
    ::Autoklav::ProcessInfo* processinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processinfo_);
  }
  _impl_.processinfo_ = processinfo;
  if (processinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Autoklav.StartProcessRequest.processInfo)
}
inline ::Autoklav::ProcessInfo* StartProcessRequest::release_processinfo() {
  
  ::Autoklav::ProcessInfo* temp = _impl_.processinfo_;
  _impl_.processinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Autoklav::ProcessInfo* StartProcessRequest::unsafe_arena_release_processinfo() {
  // @@protoc_insertion_point(field_release:Autoklav.StartProcessRequest.processInfo)
  
  ::Autoklav::ProcessInfo* temp = _impl_.processinfo_;
  _impl_.processinfo_ = nullptr;
  return temp;
}
inline ::Autoklav::ProcessInfo* StartProcessRequest::_internal_mutable_processinfo() {
  
  if (_impl_.processinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Autoklav::ProcessInfo>(GetArenaForAllocation());
    _impl_.processinfo_ = p;
  }
  return _impl_.processinfo_;
}
inline ::Autoklav::ProcessInfo* StartProcessRequest::mutable_processinfo() {
  ::Autoklav::ProcessInfo* _msg = _internal_mutable_processinfo();
  // @@protoc_insertion_point(field_mutable:Autoklav.StartProcessRequest.processInfo)
  return _msg;
}
inline void StartProcessRequest::set_allocated_processinfo(::Autoklav::ProcessInfo* processinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processinfo_;
  }
  if (processinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processinfo);
    if (message_arena != submessage_arena) {
      processinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processinfo_ = processinfo;
  // @@protoc_insertion_point(field_set_allocated:Autoklav.StartProcessRequest.processInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Autoklav

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Autoklav::ProcessConfigType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Autoklav::ProcessConfigType>() {
  return ::Autoklav::ProcessConfigType_descriptor();
}
template <> struct is_proto_enum< ::Autoklav::ProcessConfigState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Autoklav::ProcessConfigState>() {
  return ::Autoklav::ProcessConfigState_descriptor();
}
template <> struct is_proto_enum< ::Autoklav::ProcessConfigMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Autoklav::ProcessConfigMode>() {
  return ::Autoklav::ProcessConfigMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_autoklav_2eproto
