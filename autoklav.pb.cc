// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoklav.proto

#include "autoklav.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Autoklav {
PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized) {}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.errorsstring_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.errors_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
PROTOBUF_CONSTEXPR Variables::Variables(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.targetk_)*/0
  , /*decltype(_impl_.serialdatatime_)*/0
  , /*decltype(_impl_.statemachinetick_)*/0
  , /*decltype(_impl_.sterilizationtemp_)*/0
  , /*decltype(_impl_.pasterizationtemp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VariablesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VariablesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VariablesDefaultTypeInternal() {}
  union {
    Variables _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VariablesDefaultTypeInternal _Variables_default_instance_;
PROTOBUF_CONSTEXPR SetVariable::SetVariable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetVariableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetVariableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetVariableDefaultTypeInternal() {}
  union {
    SetVariable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetVariableDefaultTypeInternal _SetVariable_default_instance_;
PROTOBUF_CONSTEXPR SensorValues::SensorValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.temp_)*/0
  , /*decltype(_impl_.tempk_)*/0
  , /*decltype(_impl_.pressure_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SensorValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorValuesDefaultTypeInternal() {}
  union {
    SensorValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorValuesDefaultTypeInternal _SensorValues_default_instance_;
PROTOBUF_CONSTEXPR StateMachineValues::StateMachineValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.temp_)*/0
  , /*decltype(_impl_.tempk_)*/0
  , /*decltype(_impl_.dtemp_)*/0
  , /*decltype(_impl_.pressure_)*/0
  , /*decltype(_impl_.dr_)*/0
  , /*decltype(_impl_.fr_)*/0
  , /*decltype(_impl_.r_)*/0
  , /*decltype(_impl_.sumfr_)*/0
  , /*decltype(_impl_.sumr_)*/0
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StateMachineValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateMachineValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateMachineValuesDefaultTypeInternal() {}
  union {
    StateMachineValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateMachineValuesDefaultTypeInternal _StateMachineValues_default_instance_;
PROTOBUF_CONSTEXPR ProcessConfig::ProcessConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.customtemp_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.targetf_)*/0
  , /*decltype(_impl_.maintaintemp_)*/0
  , /*decltype(_impl_.maintainpressure_)*/0
  , /*decltype(_impl_.finishtemp_)*/0
  , /*decltype(_impl_.targettime_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessConfigDefaultTypeInternal() {}
  union {
    ProcessConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessConfigDefaultTypeInternal _ProcessConfig_default_instance_;
PROTOBUF_CONSTEXPR ProcessInfo::ProcessInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.productname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.productquantity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bacteria_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.processstart_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.processlength_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessInfoDefaultTypeInternal() {}
  union {
    ProcessInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
PROTOBUF_CONSTEXPR ProcessLogRow::ProcessLogRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.productname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.productquantity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bacteria_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.processstart_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.processlength_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessLogRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessLogRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessLogRowDefaultTypeInternal() {}
  union {
    ProcessLogRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessLogRowDefaultTypeInternal _ProcessLogRow_default_instance_;
PROTOBUF_CONSTEXPR StartProcessRequest::StartProcessRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.processconfig_)*/nullptr
  , /*decltype(_impl_.processinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StartProcessRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartProcessRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartProcessRequestDefaultTypeInternal() {}
  union {
    StartProcessRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartProcessRequestDefaultTypeInternal _StartProcessRequest_default_instance_;
}  // namespace Autoklav
static ::_pb::Metadata file_level_metadata_autoklav_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_autoklav_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_autoklav_2eproto = nullptr;

const uint32_t TableStruct_autoklav_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::Status, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Status, _impl_.errors_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Status, _impl_.errorsstring_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _impl_.targetk_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _impl_.serialdatatime_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _impl_.statemachinetick_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _impl_.sterilizationtemp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::Variables, _impl_.pasterizationtemp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::SetVariable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::SetVariable, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::SetVariable, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::SensorValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::SensorValues, _impl_.temp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::SensorValues, _impl_.tempk_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::SensorValues, _impl_.pressure_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.temp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.tempk_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.dtemp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.pressure_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.dr_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.fr_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.sumfr_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StateMachineValues, _impl_.sumr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.customtemp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.targetf_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.targettime_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.maintaintemp_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.maintainpressure_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessConfig, _impl_.finishtemp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.productname_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.productquantity_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.bacteria_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.processstart_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessInfo, _impl_.processlength_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.productname_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.productquantity_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.bacteria_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.processstart_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::ProcessLogRow, _impl_.processlength_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Autoklav::StartProcessRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Autoklav::StartProcessRequest, _impl_.processconfig_),
  PROTOBUF_FIELD_OFFSET(::Autoklav::StartProcessRequest, _impl_.processinfo_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Autoklav::Empty)},
  { 6, -1, -1, sizeof(::Autoklav::Status)},
  { 15, -1, -1, sizeof(::Autoklav::Variables)},
  { 26, -1, -1, sizeof(::Autoklav::SetVariable)},
  { 34, -1, -1, sizeof(::Autoklav::SensorValues)},
  { 43, -1, -1, sizeof(::Autoklav::StateMachineValues)},
  { 59, -1, -1, sizeof(::Autoklav::ProcessConfig)},
  { 73, -1, -1, sizeof(::Autoklav::ProcessInfo)},
  { 85, -1, -1, sizeof(::Autoklav::ProcessLogRow)},
  { 98, -1, -1, sizeof(::Autoklav::StartProcessRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Autoklav::_Empty_default_instance_._instance,
  &::Autoklav::_Status_default_instance_._instance,
  &::Autoklav::_Variables_default_instance_._instance,
  &::Autoklav::_SetVariable_default_instance_._instance,
  &::Autoklav::_SensorValues_default_instance_._instance,
  &::Autoklav::_StateMachineValues_default_instance_._instance,
  &::Autoklav::_ProcessConfig_default_instance_._instance,
  &::Autoklav::_ProcessInfo_default_instance_._instance,
  &::Autoklav::_ProcessLogRow_default_instance_._instance,
  &::Autoklav::_StartProcessRequest_default_instance_._instance,
};

const char descriptor_table_protodef_autoklav_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016autoklav.proto\022\010Autoklav\"\007\n\005Empty\"<\n\006S"
  "tatus\022\014\n\004code\030\001 \001(\005\022\016\n\006errors\030\002 \001(\005\022\024\n\014e"
  "rrorsString\030\003 \001(\t\"\204\001\n\tVariables\022\017\n\007targe"
  "tK\030\001 \001(\001\022\026\n\016serialDataTime\030\002 \001(\005\022\030\n\020stat"
  "eMachineTick\030\003 \001(\005\022\031\n\021sterilizationTemp\030"
  "\004 \001(\001\022\031\n\021pasterizationTemp\030\005 \001(\001\"*\n\013SetV"
  "ariable\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"=\n\014"
  "SensorValues\022\014\n\004temp\030\001 \001(\001\022\r\n\005tempK\030\002 \001("
  "\001\022\020\n\010pressure\030\003 \001(\001\"\240\001\n\022StateMachineValu"
  "es\022\014\n\004time\030\001 \001(\r\022\014\n\004temp\030\002 \001(\001\022\r\n\005tempK\030"
  "\003 \001(\001\022\r\n\005dTemp\030\004 \001(\001\022\020\n\010pressure\030\005 \001(\001\022\n"
  "\n\002Dr\030\006 \001(\001\022\n\n\002Fr\030\007 \001(\001\022\t\n\001r\030\010 \001(\001\022\r\n\005sum"
  "Fr\030\t \001(\001\022\014\n\004sumr\030\n \001(\001\"\342\001\n\rProcessConfig"
  "\022)\n\004type\030\001 \001(\0162\033.Autoklav.ProcessConfigT"
  "ype\022\022\n\ncustomTemp\030\002 \001(\001\022)\n\004mode\030\003 \001(\0162\033."
  "Autoklav.ProcessConfigMode\022\017\n\007targetF\030\004 "
  "\001(\001\022\022\n\ntargetTime\030\005 \001(\r\022\024\n\014maintainTemp\030"
  "\006 \001(\001\022\030\n\020maintainPressure\030\007 \001(\001\022\022\n\nfinis"
  "hTemp\030\010 \001(\001\"\217\001\n\013ProcessInfo\022\023\n\013productNa"
  "me\030\001 \001(\t\022\027\n\017productQuantity\030\002 \001(\t\022\020\n\010bac"
  "teria\030\003 \001(\t\022\023\n\013description\030\004 \001(\t\022\024\n\014proc"
  "essStart\030\005 \001(\t\022\025\n\rprocessLength\030\006 \001(\t\"\235\001"
  "\n\rProcessLogRow\022\n\n\002id\030\001 \001(\005\022\023\n\013productNa"
  "me\030\002 \001(\t\022\027\n\017productQuantity\030\003 \001(\t\022\020\n\010bac"
  "teria\030\004 \001(\t\022\023\n\013description\030\005 \001(\t\022\024\n\014proc"
  "essStart\030\006 \001(\t\022\025\n\rprocessLength\030\007 \001(\t\"q\n"
  "\023StartProcessRequest\022.\n\rprocessConfig\030\001 "
  "\001(\0132\027.Autoklav.ProcessConfig\022*\n\013processI"
  "nfo\030\002 \001(\0132\025.Autoklav.ProcessInfo*E\n\021Proc"
  "essConfigType\022\021\n\rSTERILIZATION\020\000\022\021\n\rPAST"
  "ERIZATION\020\001\022\n\n\006CUSTOM\020\002*q\n\022ProcessConfig"
  "State\022\t\n\005READY\020\000\022\014\n\010STARTING\020\001\022\013\n\007FILLIN"
  "G\020\002\022\013\n\007HEATING\020\003\022\013\n\007COOLING\020\004\022\r\n\tFINISHI"
  "NG\020\005\022\014\n\010FINISHED\020\006**\n\021ProcessConfigMode\022"
  "\013\n\007TARGETF\020\000\022\010\n\004TIME\020\0012\237\003\n\010Autoklav\022.\n\tg"
  "etStatus\022\017.Autoklav.Empty\032\020.Autoklav.Sta"
  "tus\0224\n\014getVariables\022\017.Autoklav.Empty\032\023.A"
  "utoklav.Variables\0226\n\013setVariable\022\025.Autok"
  "lav.SetVariable\032\020.Autoklav.Status\022\?\n\014sta"
  "rtProcess\022\035.Autoklav.StartProcessRequest"
  "\032\020.Autoklav.Status\0220\n\013stopProcess\022\017.Auto"
  "klav.Empty\032\020.Autoklav.Status\022:\n\017getSenso"
  "rValues\022\017.Autoklav.Empty\032\026.Autoklav.Sens"
  "orValues\022F\n\025getStateMachineValues\022\017.Auto"
  "klav.Empty\032\034.Autoklav.StateMachineValues"
  "b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_autoklav_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_autoklav_2eproto = {
    false, false, 1808, descriptor_table_protodef_autoklav_2eproto,
    "autoklav.proto",
    &descriptor_table_autoklav_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_autoklav_2eproto::offsets,
    file_level_metadata_autoklav_2eproto, file_level_enum_descriptors_autoklav_2eproto,
    file_level_service_descriptors_autoklav_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_autoklav_2eproto_getter() {
  return &descriptor_table_autoklav_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_autoklav_2eproto(&descriptor_table_autoklav_2eproto);
namespace Autoklav {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoklav_2eproto);
  return file_level_enum_descriptors_autoklav_2eproto[0];
}
bool ProcessConfigType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoklav_2eproto);
  return file_level_enum_descriptors_autoklav_2eproto[1];
}
bool ProcessConfigState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessConfigMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoklav_2eproto);
  return file_level_enum_descriptors_autoklav_2eproto[2];
}
bool ProcessConfigMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Autoklav.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Empty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Autoklav.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[0]);
}

// ===================================================================

class Status::_Internal {
 public:
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Status* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.errorsstring_){}
    , decltype(_impl_.code_){}
    , decltype(_impl_.errors_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.errorsstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errorsstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_errorsstring().empty()) {
    _this->_impl_.errorsstring_.Set(from._internal_errorsstring(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.errors_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.errors_));
  // @@protoc_insertion_point(copy_constructor:Autoklav.Status)
}

inline void Status::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.errorsstring_){}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.errors_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.errorsstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errorsstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:Autoklav.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.errorsstring_.Destroy();
}

void Status::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.errorsstring_.ClearToEmpty();
  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.errors_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.errors_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 errors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string errorsString = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_errorsstring();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.Status.errorsString"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // int32 errors = 2;
  if (this->_internal_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_errors(), target);
  }

  // string errorsString = 3;
  if (!this->_internal_errorsstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_errorsstring().data(), static_cast<int>(this->_internal_errorsstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.Status.errorsString");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_errorsstring(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string errorsString = 3;
  if (!this->_internal_errorsstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_errorsstring());
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // int32 errors = 2;
  if (this->_internal_errors() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_errors());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Status::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Status::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Status::GetClassData() const { return &_class_data_; }


void Status::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Status*>(&to_msg);
  auto& from = static_cast<const Status&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.Status)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_errorsstring().empty()) {
    _this->_internal_set_errorsstring(from._internal_errorsstring());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_errors() != 0) {
    _this->_internal_set_errors(from._internal_errors());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.errorsstring_, lhs_arena,
      &other->_impl_.errorsstring_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, _impl_.errors_)
      + sizeof(Status::_impl_.errors_)
      - PROTOBUF_FIELD_OFFSET(Status, _impl_.code_)>(
          reinterpret_cast<char*>(&_impl_.code_),
          reinterpret_cast<char*>(&other->_impl_.code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[1]);
}

// ===================================================================

class Variables::_Internal {
 public:
};

Variables::Variables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.Variables)
}
Variables::Variables(const Variables& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Variables* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.targetk_){}
    , decltype(_impl_.serialdatatime_){}
    , decltype(_impl_.statemachinetick_){}
    , decltype(_impl_.sterilizationtemp_){}
    , decltype(_impl_.pasterizationtemp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.targetk_, &from._impl_.targetk_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pasterizationtemp_) -
    reinterpret_cast<char*>(&_impl_.targetk_)) + sizeof(_impl_.pasterizationtemp_));
  // @@protoc_insertion_point(copy_constructor:Autoklav.Variables)
}

inline void Variables::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.targetk_){0}
    , decltype(_impl_.serialdatatime_){0}
    , decltype(_impl_.statemachinetick_){0}
    , decltype(_impl_.sterilizationtemp_){0}
    , decltype(_impl_.pasterizationtemp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Variables::~Variables() {
  // @@protoc_insertion_point(destructor:Autoklav.Variables)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Variables::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Variables::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Variables::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.Variables)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.targetk_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pasterizationtemp_) -
      reinterpret_cast<char*>(&_impl_.targetk_)) + sizeof(_impl_.pasterizationtemp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Variables::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double targetK = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.targetk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 serialDataTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.serialdatatime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 stateMachineTick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.statemachinetick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double sterilizationTemp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.sterilizationtemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pasterizationTemp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.pasterizationtemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Variables::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.Variables)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double targetK = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetk = this->_internal_targetk();
  uint64_t raw_targetk;
  memcpy(&raw_targetk, &tmp_targetk, sizeof(tmp_targetk));
  if (raw_targetk != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_targetk(), target);
  }

  // int32 serialDataTime = 2;
  if (this->_internal_serialdatatime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_serialdatatime(), target);
  }

  // int32 stateMachineTick = 3;
  if (this->_internal_statemachinetick() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_statemachinetick(), target);
  }

  // double sterilizationTemp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sterilizationtemp = this->_internal_sterilizationtemp();
  uint64_t raw_sterilizationtemp;
  memcpy(&raw_sterilizationtemp, &tmp_sterilizationtemp, sizeof(tmp_sterilizationtemp));
  if (raw_sterilizationtemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_sterilizationtemp(), target);
  }

  // double pasterizationTemp = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pasterizationtemp = this->_internal_pasterizationtemp();
  uint64_t raw_pasterizationtemp;
  memcpy(&raw_pasterizationtemp, &tmp_pasterizationtemp, sizeof(tmp_pasterizationtemp));
  if (raw_pasterizationtemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_pasterizationtemp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.Variables)
  return target;
}

size_t Variables::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.Variables)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double targetK = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetk = this->_internal_targetk();
  uint64_t raw_targetk;
  memcpy(&raw_targetk, &tmp_targetk, sizeof(tmp_targetk));
  if (raw_targetk != 0) {
    total_size += 1 + 8;
  }

  // int32 serialDataTime = 2;
  if (this->_internal_serialdatatime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serialdatatime());
  }

  // int32 stateMachineTick = 3;
  if (this->_internal_statemachinetick() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_statemachinetick());
  }

  // double sterilizationTemp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sterilizationtemp = this->_internal_sterilizationtemp();
  uint64_t raw_sterilizationtemp;
  memcpy(&raw_sterilizationtemp, &tmp_sterilizationtemp, sizeof(tmp_sterilizationtemp));
  if (raw_sterilizationtemp != 0) {
    total_size += 1 + 8;
  }

  // double pasterizationTemp = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pasterizationtemp = this->_internal_pasterizationtemp();
  uint64_t raw_pasterizationtemp;
  memcpy(&raw_pasterizationtemp, &tmp_pasterizationtemp, sizeof(tmp_pasterizationtemp));
  if (raw_pasterizationtemp != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Variables::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Variables::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Variables::GetClassData() const { return &_class_data_; }


void Variables::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Variables*>(&to_msg);
  auto& from = static_cast<const Variables&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.Variables)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetk = from._internal_targetk();
  uint64_t raw_targetk;
  memcpy(&raw_targetk, &tmp_targetk, sizeof(tmp_targetk));
  if (raw_targetk != 0) {
    _this->_internal_set_targetk(from._internal_targetk());
  }
  if (from._internal_serialdatatime() != 0) {
    _this->_internal_set_serialdatatime(from._internal_serialdatatime());
  }
  if (from._internal_statemachinetick() != 0) {
    _this->_internal_set_statemachinetick(from._internal_statemachinetick());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sterilizationtemp = from._internal_sterilizationtemp();
  uint64_t raw_sterilizationtemp;
  memcpy(&raw_sterilizationtemp, &tmp_sterilizationtemp, sizeof(tmp_sterilizationtemp));
  if (raw_sterilizationtemp != 0) {
    _this->_internal_set_sterilizationtemp(from._internal_sterilizationtemp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pasterizationtemp = from._internal_pasterizationtemp();
  uint64_t raw_pasterizationtemp;
  memcpy(&raw_pasterizationtemp, &tmp_pasterizationtemp, sizeof(tmp_pasterizationtemp));
  if (raw_pasterizationtemp != 0) {
    _this->_internal_set_pasterizationtemp(from._internal_pasterizationtemp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Variables::CopyFrom(const Variables& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.Variables)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Variables::IsInitialized() const {
  return true;
}

void Variables::InternalSwap(Variables* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Variables, _impl_.pasterizationtemp_)
      + sizeof(Variables::_impl_.pasterizationtemp_)
      - PROTOBUF_FIELD_OFFSET(Variables, _impl_.targetk_)>(
          reinterpret_cast<char*>(&_impl_.targetk_),
          reinterpret_cast<char*>(&other->_impl_.targetk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Variables::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[2]);
}

// ===================================================================

class SetVariable::_Internal {
 public:
};

SetVariable::SetVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.SetVariable)
}
SetVariable::SetVariable(const SetVariable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetVariable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Autoklav.SetVariable)
}

inline void SetVariable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetVariable::~SetVariable() {
  // @@protoc_insertion_point(destructor:Autoklav.SetVariable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetVariable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void SetVariable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetVariable::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.SetVariable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetVariable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.SetVariable.name"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.SetVariable.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetVariable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.SetVariable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.SetVariable.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.SetVariable.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.SetVariable)
  return target;
}

size_t SetVariable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.SetVariable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetVariable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetVariable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetVariable::GetClassData() const { return &_class_data_; }


void SetVariable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetVariable*>(&to_msg);
  auto& from = static_cast<const SetVariable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.SetVariable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetVariable::CopyFrom(const SetVariable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.SetVariable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetVariable::IsInitialized() const {
  return true;
}

void SetVariable::InternalSwap(SetVariable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SetVariable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[3]);
}

// ===================================================================

class SensorValues::_Internal {
 public:
};

SensorValues::SensorValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.SensorValues)
}
SensorValues::SensorValues(const SensorValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.temp_){}
    , decltype(_impl_.tempk_){}
    , decltype(_impl_.pressure_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.temp_, &from._impl_.temp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pressure_) -
    reinterpret_cast<char*>(&_impl_.temp_)) + sizeof(_impl_.pressure_));
  // @@protoc_insertion_point(copy_constructor:Autoklav.SensorValues)
}

inline void SensorValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.temp_){0}
    , decltype(_impl_.tempk_){0}
    , decltype(_impl_.pressure_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SensorValues::~SensorValues() {
  // @@protoc_insertion_point(destructor:Autoklav.SensorValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorValues::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.SensorValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.temp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pressure_) -
      reinterpret_cast<char*>(&_impl_.temp_)) + sizeof(_impl_.pressure_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double temp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.temp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double tempK = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.tempk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pressure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.pressure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.SensorValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double temp = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = this->_internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_temp(), target);
  }

  // double tempK = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = this->_internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_tempk(), target);
  }

  // double pressure = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = this->_internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_pressure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.SensorValues)
  return target;
}

size_t SensorValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.SensorValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double temp = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = this->_internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    total_size += 1 + 8;
  }

  // double tempK = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = this->_internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    total_size += 1 + 8;
  }

  // double pressure = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = this->_internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorValues::GetClassData() const { return &_class_data_; }


void SensorValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorValues*>(&to_msg);
  auto& from = static_cast<const SensorValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.SensorValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = from._internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    _this->_internal_set_temp(from._internal_temp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = from._internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    _this->_internal_set_tempk(from._internal_tempk());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = from._internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    _this->_internal_set_pressure(from._internal_pressure());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorValues::CopyFrom(const SensorValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.SensorValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorValues::IsInitialized() const {
  return true;
}

void SensorValues::InternalSwap(SensorValues* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorValues, _impl_.pressure_)
      + sizeof(SensorValues::_impl_.pressure_)
      - PROTOBUF_FIELD_OFFSET(SensorValues, _impl_.temp_)>(
          reinterpret_cast<char*>(&_impl_.temp_),
          reinterpret_cast<char*>(&other->_impl_.temp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[4]);
}

// ===================================================================

class StateMachineValues::_Internal {
 public:
};

StateMachineValues::StateMachineValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.StateMachineValues)
}
StateMachineValues::StateMachineValues(const StateMachineValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StateMachineValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.temp_){}
    , decltype(_impl_.tempk_){}
    , decltype(_impl_.dtemp_){}
    , decltype(_impl_.pressure_){}
    , decltype(_impl_.dr_){}
    , decltype(_impl_.fr_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.sumfr_){}
    , decltype(_impl_.sumr_){}
    , decltype(_impl_.time_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.temp_, &from._impl_.temp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_) -
    reinterpret_cast<char*>(&_impl_.temp_)) + sizeof(_impl_.time_));
  // @@protoc_insertion_point(copy_constructor:Autoklav.StateMachineValues)
}

inline void StateMachineValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.temp_){0}
    , decltype(_impl_.tempk_){0}
    , decltype(_impl_.dtemp_){0}
    , decltype(_impl_.pressure_){0}
    , decltype(_impl_.dr_){0}
    , decltype(_impl_.fr_){0}
    , decltype(_impl_.r_){0}
    , decltype(_impl_.sumfr_){0}
    , decltype(_impl_.sumr_){0}
    , decltype(_impl_.time_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StateMachineValues::~StateMachineValues() {
  // @@protoc_insertion_point(destructor:Autoklav.StateMachineValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StateMachineValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StateMachineValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StateMachineValues::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.StateMachineValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.temp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.time_) -
      reinterpret_cast<char*>(&_impl_.temp_)) + sizeof(_impl_.time_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StateMachineValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double temp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.temp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double tempK = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.tempk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double dTemp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.dtemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pressure = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.pressure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double Dr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.dr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double Fr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.fr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double r = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double sumFr = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.sumfr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double sumr = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.sumr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateMachineValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.StateMachineValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 time = 1;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time(), target);
  }

  // double temp = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = this->_internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_temp(), target);
  }

  // double tempK = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = this->_internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_tempk(), target);
  }

  // double dTemp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dtemp = this->_internal_dtemp();
  uint64_t raw_dtemp;
  memcpy(&raw_dtemp, &tmp_dtemp, sizeof(tmp_dtemp));
  if (raw_dtemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_dtemp(), target);
  }

  // double pressure = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = this->_internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_pressure(), target);
  }

  // double Dr = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dr = this->_internal_dr();
  uint64_t raw_dr;
  memcpy(&raw_dr, &tmp_dr, sizeof(tmp_dr));
  if (raw_dr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_dr(), target);
  }

  // double Fr = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fr = this->_internal_fr();
  uint64_t raw_fr;
  memcpy(&raw_fr, &tmp_fr, sizeof(tmp_fr));
  if (raw_fr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_fr(), target);
  }

  // double r = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_r(), target);
  }

  // double sumFr = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumfr = this->_internal_sumfr();
  uint64_t raw_sumfr;
  memcpy(&raw_sumfr, &tmp_sumfr, sizeof(tmp_sumfr));
  if (raw_sumfr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_sumfr(), target);
  }

  // double sumr = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumr = this->_internal_sumr();
  uint64_t raw_sumr;
  memcpy(&raw_sumr, &tmp_sumr, sizeof(tmp_sumr));
  if (raw_sumr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_sumr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.StateMachineValues)
  return target;
}

size_t StateMachineValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.StateMachineValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double temp = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = this->_internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    total_size += 1 + 8;
  }

  // double tempK = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = this->_internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    total_size += 1 + 8;
  }

  // double dTemp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dtemp = this->_internal_dtemp();
  uint64_t raw_dtemp;
  memcpy(&raw_dtemp, &tmp_dtemp, sizeof(tmp_dtemp));
  if (raw_dtemp != 0) {
    total_size += 1 + 8;
  }

  // double pressure = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = this->_internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    total_size += 1 + 8;
  }

  // double Dr = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dr = this->_internal_dr();
  uint64_t raw_dr;
  memcpy(&raw_dr, &tmp_dr, sizeof(tmp_dr));
  if (raw_dr != 0) {
    total_size += 1 + 8;
  }

  // double Fr = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fr = this->_internal_fr();
  uint64_t raw_fr;
  memcpy(&raw_fr, &tmp_fr, sizeof(tmp_fr));
  if (raw_fr != 0) {
    total_size += 1 + 8;
  }

  // double r = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = this->_internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 1 + 8;
  }

  // double sumFr = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumfr = this->_internal_sumfr();
  uint64_t raw_sumfr;
  memcpy(&raw_sumfr, &tmp_sumfr, sizeof(tmp_sumfr));
  if (raw_sumfr != 0) {
    total_size += 1 + 8;
  }

  // double sumr = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumr = this->_internal_sumr();
  uint64_t raw_sumr;
  memcpy(&raw_sumr, &tmp_sumr, sizeof(tmp_sumr));
  if (raw_sumr != 0) {
    total_size += 1 + 8;
  }

  // uint32 time = 1;
  if (this->_internal_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StateMachineValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StateMachineValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StateMachineValues::GetClassData() const { return &_class_data_; }


void StateMachineValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StateMachineValues*>(&to_msg);
  auto& from = static_cast<const StateMachineValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.StateMachineValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_temp = from._internal_temp();
  uint64_t raw_temp;
  memcpy(&raw_temp, &tmp_temp, sizeof(tmp_temp));
  if (raw_temp != 0) {
    _this->_internal_set_temp(from._internal_temp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tempk = from._internal_tempk();
  uint64_t raw_tempk;
  memcpy(&raw_tempk, &tmp_tempk, sizeof(tmp_tempk));
  if (raw_tempk != 0) {
    _this->_internal_set_tempk(from._internal_tempk());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dtemp = from._internal_dtemp();
  uint64_t raw_dtemp;
  memcpy(&raw_dtemp, &tmp_dtemp, sizeof(tmp_dtemp));
  if (raw_dtemp != 0) {
    _this->_internal_set_dtemp(from._internal_dtemp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pressure = from._internal_pressure();
  uint64_t raw_pressure;
  memcpy(&raw_pressure, &tmp_pressure, sizeof(tmp_pressure));
  if (raw_pressure != 0) {
    _this->_internal_set_pressure(from._internal_pressure());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dr = from._internal_dr();
  uint64_t raw_dr;
  memcpy(&raw_dr, &tmp_dr, sizeof(tmp_dr));
  if (raw_dr != 0) {
    _this->_internal_set_dr(from._internal_dr());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fr = from._internal_fr();
  uint64_t raw_fr;
  memcpy(&raw_fr, &tmp_fr, sizeof(tmp_fr));
  if (raw_fr != 0) {
    _this->_internal_set_fr(from._internal_fr());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_r = from._internal_r();
  uint64_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumfr = from._internal_sumfr();
  uint64_t raw_sumfr;
  memcpy(&raw_sumfr, &tmp_sumfr, sizeof(tmp_sumfr));
  if (raw_sumfr != 0) {
    _this->_internal_set_sumfr(from._internal_sumfr());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sumr = from._internal_sumr();
  uint64_t raw_sumr;
  memcpy(&raw_sumr, &tmp_sumr, sizeof(tmp_sumr));
  if (raw_sumr != 0) {
    _this->_internal_set_sumr(from._internal_sumr());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StateMachineValues::CopyFrom(const StateMachineValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.StateMachineValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateMachineValues::IsInitialized() const {
  return true;
}

void StateMachineValues::InternalSwap(StateMachineValues* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StateMachineValues, _impl_.time_)
      + sizeof(StateMachineValues::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(StateMachineValues, _impl_.temp_)>(
          reinterpret_cast<char*>(&_impl_.temp_),
          reinterpret_cast<char*>(&other->_impl_.temp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StateMachineValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[5]);
}

// ===================================================================

class ProcessConfig::_Internal {
 public:
};

ProcessConfig::ProcessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.ProcessConfig)
}
ProcessConfig::ProcessConfig(const ProcessConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProcessConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.customtemp_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.targetf_){}
    , decltype(_impl_.maintaintemp_){}
    , decltype(_impl_.maintainpressure_){}
    , decltype(_impl_.finishtemp_){}
    , decltype(_impl_.targettime_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.customtemp_, &from._impl_.customtemp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.targettime_) -
    reinterpret_cast<char*>(&_impl_.customtemp_)) + sizeof(_impl_.targettime_));
  // @@protoc_insertion_point(copy_constructor:Autoklav.ProcessConfig)
}

inline void ProcessConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.customtemp_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.targetf_){0}
    , decltype(_impl_.maintaintemp_){0}
    , decltype(_impl_.maintainpressure_){0}
    , decltype(_impl_.finishtemp_){0}
    , decltype(_impl_.targettime_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProcessConfig::~ProcessConfig() {
  // @@protoc_insertion_point(destructor:Autoklav.ProcessConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProcessConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.ProcessConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.customtemp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.targettime_) -
      reinterpret_cast<char*>(&_impl_.customtemp_)) + sizeof(_impl_.targettime_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProcessConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Autoklav.ProcessConfigType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Autoklav::ProcessConfigType>(val));
        } else
          goto handle_unusual;
        continue;
      // double customTemp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.customtemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .Autoklav.ProcessConfigMode mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::Autoklav::ProcessConfigMode>(val));
        } else
          goto handle_unusual;
        continue;
      // double targetF = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.targetf_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint32 targetTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.targettime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double maintainTemp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.maintaintemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double maintainPressure = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.maintainpressure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double finishTemp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.finishtemp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.ProcessConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Autoklav.ProcessConfigType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // double customTemp = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_customtemp = this->_internal_customtemp();
  uint64_t raw_customtemp;
  memcpy(&raw_customtemp, &tmp_customtemp, sizeof(tmp_customtemp));
  if (raw_customtemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_customtemp(), target);
  }

  // .Autoklav.ProcessConfigMode mode = 3;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mode(), target);
  }

  // double targetF = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetf = this->_internal_targetf();
  uint64_t raw_targetf;
  memcpy(&raw_targetf, &tmp_targetf, sizeof(tmp_targetf));
  if (raw_targetf != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_targetf(), target);
  }

  // uint32 targetTime = 5;
  if (this->_internal_targettime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_targettime(), target);
  }

  // double maintainTemp = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintaintemp = this->_internal_maintaintemp();
  uint64_t raw_maintaintemp;
  memcpy(&raw_maintaintemp, &tmp_maintaintemp, sizeof(tmp_maintaintemp));
  if (raw_maintaintemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_maintaintemp(), target);
  }

  // double maintainPressure = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintainpressure = this->_internal_maintainpressure();
  uint64_t raw_maintainpressure;
  memcpy(&raw_maintainpressure, &tmp_maintainpressure, sizeof(tmp_maintainpressure));
  if (raw_maintainpressure != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_maintainpressure(), target);
  }

  // double finishTemp = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_finishtemp = this->_internal_finishtemp();
  uint64_t raw_finishtemp;
  memcpy(&raw_finishtemp, &tmp_finishtemp, sizeof(tmp_finishtemp));
  if (raw_finishtemp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_finishtemp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.ProcessConfig)
  return target;
}

size_t ProcessConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.ProcessConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double customTemp = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_customtemp = this->_internal_customtemp();
  uint64_t raw_customtemp;
  memcpy(&raw_customtemp, &tmp_customtemp, sizeof(tmp_customtemp));
  if (raw_customtemp != 0) {
    total_size += 1 + 8;
  }

  // .Autoklav.ProcessConfigType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // .Autoklav.ProcessConfigMode mode = 3;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  // double targetF = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetf = this->_internal_targetf();
  uint64_t raw_targetf;
  memcpy(&raw_targetf, &tmp_targetf, sizeof(tmp_targetf));
  if (raw_targetf != 0) {
    total_size += 1 + 8;
  }

  // double maintainTemp = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintaintemp = this->_internal_maintaintemp();
  uint64_t raw_maintaintemp;
  memcpy(&raw_maintaintemp, &tmp_maintaintemp, sizeof(tmp_maintaintemp));
  if (raw_maintaintemp != 0) {
    total_size += 1 + 8;
  }

  // double maintainPressure = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintainpressure = this->_internal_maintainpressure();
  uint64_t raw_maintainpressure;
  memcpy(&raw_maintainpressure, &tmp_maintainpressure, sizeof(tmp_maintainpressure));
  if (raw_maintainpressure != 0) {
    total_size += 1 + 8;
  }

  // double finishTemp = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_finishtemp = this->_internal_finishtemp();
  uint64_t raw_finishtemp;
  memcpy(&raw_finishtemp, &tmp_finishtemp, sizeof(tmp_finishtemp));
  if (raw_finishtemp != 0) {
    total_size += 1 + 8;
  }

  // uint32 targetTime = 5;
  if (this->_internal_targettime() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_targettime());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProcessConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProcessConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProcessConfig::GetClassData() const { return &_class_data_; }


void ProcessConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProcessConfig*>(&to_msg);
  auto& from = static_cast<const ProcessConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.ProcessConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_customtemp = from._internal_customtemp();
  uint64_t raw_customtemp;
  memcpy(&raw_customtemp, &tmp_customtemp, sizeof(tmp_customtemp));
  if (raw_customtemp != 0) {
    _this->_internal_set_customtemp(from._internal_customtemp());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_targetf = from._internal_targetf();
  uint64_t raw_targetf;
  memcpy(&raw_targetf, &tmp_targetf, sizeof(tmp_targetf));
  if (raw_targetf != 0) {
    _this->_internal_set_targetf(from._internal_targetf());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintaintemp = from._internal_maintaintemp();
  uint64_t raw_maintaintemp;
  memcpy(&raw_maintaintemp, &tmp_maintaintemp, sizeof(tmp_maintaintemp));
  if (raw_maintaintemp != 0) {
    _this->_internal_set_maintaintemp(from._internal_maintaintemp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maintainpressure = from._internal_maintainpressure();
  uint64_t raw_maintainpressure;
  memcpy(&raw_maintainpressure, &tmp_maintainpressure, sizeof(tmp_maintainpressure));
  if (raw_maintainpressure != 0) {
    _this->_internal_set_maintainpressure(from._internal_maintainpressure());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_finishtemp = from._internal_finishtemp();
  uint64_t raw_finishtemp;
  memcpy(&raw_finishtemp, &tmp_finishtemp, sizeof(tmp_finishtemp));
  if (raw_finishtemp != 0) {
    _this->_internal_set_finishtemp(from._internal_finishtemp());
  }
  if (from._internal_targettime() != 0) {
    _this->_internal_set_targettime(from._internal_targettime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProcessConfig::CopyFrom(const ProcessConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.ProcessConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessConfig::IsInitialized() const {
  return true;
}

void ProcessConfig::InternalSwap(ProcessConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessConfig, _impl_.targettime_)
      + sizeof(ProcessConfig::_impl_.targettime_)
      - PROTOBUF_FIELD_OFFSET(ProcessConfig, _impl_.customtemp_)>(
          reinterpret_cast<char*>(&_impl_.customtemp_),
          reinterpret_cast<char*>(&other->_impl_.customtemp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProcessConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[6]);
}

// ===================================================================

class ProcessInfo::_Internal {
 public:
};

ProcessInfo::ProcessInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.ProcessInfo)
}
ProcessInfo::ProcessInfo(const ProcessInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProcessInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.productname_){}
    , decltype(_impl_.productquantity_){}
    , decltype(_impl_.bacteria_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.processstart_){}
    , decltype(_impl_.processlength_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.productname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_productname().empty()) {
    _this->_impl_.productname_.Set(from._internal_productname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.productquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_productquantity().empty()) {
    _this->_impl_.productquantity_.Set(from._internal_productquantity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bacteria_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bacteria().empty()) {
    _this->_impl_.bacteria_.Set(from._internal_bacteria(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.processstart_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processstart_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_processstart().empty()) {
    _this->_impl_.processstart_.Set(from._internal_processstart(), 
      _this->GetArenaForAllocation());
  }
  _impl_.processlength_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processlength_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_processlength().empty()) {
    _this->_impl_.processlength_.Set(from._internal_processlength(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Autoklav.ProcessInfo)
}

inline void ProcessInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.productname_){}
    , decltype(_impl_.productquantity_){}
    , decltype(_impl_.bacteria_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.processstart_){}
    , decltype(_impl_.processlength_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.productname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bacteria_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.processstart_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processstart_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.processlength_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processlength_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProcessInfo::~ProcessInfo() {
  // @@protoc_insertion_point(destructor:Autoklav.ProcessInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productname_.Destroy();
  _impl_.productquantity_.Destroy();
  _impl_.bacteria_.Destroy();
  _impl_.description_.Destroy();
  _impl_.processstart_.Destroy();
  _impl_.processlength_.Destroy();
}

void ProcessInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.ProcessInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.productname_.ClearToEmpty();
  _impl_.productquantity_.ClearToEmpty();
  _impl_.bacteria_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.processstart_.ClearToEmpty();
  _impl_.processlength_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProcessInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string productName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_productname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.productName"));
        } else
          goto handle_unusual;
        continue;
      // string productQuantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_productquantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.productQuantity"));
        } else
          goto handle_unusual;
        continue;
      // string bacteria = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bacteria();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.bacteria"));
        } else
          goto handle_unusual;
        continue;
      // string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.description"));
        } else
          goto handle_unusual;
        continue;
      // string processStart = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_processstart();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.processStart"));
        } else
          goto handle_unusual;
        continue;
      // string processLength = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_processlength();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessInfo.processLength"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.ProcessInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string productName = 1;
  if (!this->_internal_productname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_productname().data(), static_cast<int>(this->_internal_productname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.productName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_productname(), target);
  }

  // string productQuantity = 2;
  if (!this->_internal_productquantity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_productquantity().data(), static_cast<int>(this->_internal_productquantity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.productQuantity");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_productquantity(), target);
  }

  // string bacteria = 3;
  if (!this->_internal_bacteria().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bacteria().data(), static_cast<int>(this->_internal_bacteria().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.bacteria");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bacteria(), target);
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.description");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // string processStart = 5;
  if (!this->_internal_processstart().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_processstart().data(), static_cast<int>(this->_internal_processstart().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.processStart");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_processstart(), target);
  }

  // string processLength = 6;
  if (!this->_internal_processlength().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_processlength().data(), static_cast<int>(this->_internal_processlength().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessInfo.processLength");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_processlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.ProcessInfo)
  return target;
}

size_t ProcessInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.ProcessInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string productName = 1;
  if (!this->_internal_productname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_productname());
  }

  // string productQuantity = 2;
  if (!this->_internal_productquantity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_productquantity());
  }

  // string bacteria = 3;
  if (!this->_internal_bacteria().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bacteria());
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string processStart = 5;
  if (!this->_internal_processstart().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_processstart());
  }

  // string processLength = 6;
  if (!this->_internal_processlength().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_processlength());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProcessInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProcessInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProcessInfo::GetClassData() const { return &_class_data_; }


void ProcessInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProcessInfo*>(&to_msg);
  auto& from = static_cast<const ProcessInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.ProcessInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_productname().empty()) {
    _this->_internal_set_productname(from._internal_productname());
  }
  if (!from._internal_productquantity().empty()) {
    _this->_internal_set_productquantity(from._internal_productquantity());
  }
  if (!from._internal_bacteria().empty()) {
    _this->_internal_set_bacteria(from._internal_bacteria());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_processstart().empty()) {
    _this->_internal_set_processstart(from._internal_processstart());
  }
  if (!from._internal_processlength().empty()) {
    _this->_internal_set_processlength(from._internal_processlength());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProcessInfo::CopyFrom(const ProcessInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.ProcessInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessInfo::IsInitialized() const {
  return true;
}

void ProcessInfo::InternalSwap(ProcessInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productname_, lhs_arena,
      &other->_impl_.productname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productquantity_, lhs_arena,
      &other->_impl_.productquantity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bacteria_, lhs_arena,
      &other->_impl_.bacteria_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.processstart_, lhs_arena,
      &other->_impl_.processstart_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.processlength_, lhs_arena,
      &other->_impl_.processlength_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ProcessInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[7]);
}

// ===================================================================

class ProcessLogRow::_Internal {
 public:
};

ProcessLogRow::ProcessLogRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.ProcessLogRow)
}
ProcessLogRow::ProcessLogRow(const ProcessLogRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProcessLogRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.productname_){}
    , decltype(_impl_.productquantity_){}
    , decltype(_impl_.bacteria_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.processstart_){}
    , decltype(_impl_.processlength_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.productname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_productname().empty()) {
    _this->_impl_.productname_.Set(from._internal_productname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.productquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_productquantity().empty()) {
    _this->_impl_.productquantity_.Set(from._internal_productquantity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bacteria_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bacteria().empty()) {
    _this->_impl_.bacteria_.Set(from._internal_bacteria(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.processstart_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processstart_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_processstart().empty()) {
    _this->_impl_.processstart_.Set(from._internal_processstart(), 
      _this->GetArenaForAllocation());
  }
  _impl_.processlength_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processlength_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_processlength().empty()) {
    _this->_impl_.processlength_.Set(from._internal_processlength(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Autoklav.ProcessLogRow)
}

inline void ProcessLogRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.productname_){}
    , decltype(_impl_.productquantity_){}
    , decltype(_impl_.bacteria_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.processstart_){}
    , decltype(_impl_.processlength_){}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.productname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productquantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.productquantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bacteria_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bacteria_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.processstart_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processstart_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.processlength_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.processlength_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProcessLogRow::~ProcessLogRow() {
  // @@protoc_insertion_point(destructor:Autoklav.ProcessLogRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessLogRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productname_.Destroy();
  _impl_.productquantity_.Destroy();
  _impl_.bacteria_.Destroy();
  _impl_.description_.Destroy();
  _impl_.processstart_.Destroy();
  _impl_.processlength_.Destroy();
}

void ProcessLogRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessLogRow::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.ProcessLogRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.productname_.ClearToEmpty();
  _impl_.productquantity_.ClearToEmpty();
  _impl_.bacteria_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.processstart_.ClearToEmpty();
  _impl_.processlength_.ClearToEmpty();
  _impl_.id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProcessLogRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string productName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_productname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.productName"));
        } else
          goto handle_unusual;
        continue;
      // string productQuantity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_productquantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.productQuantity"));
        } else
          goto handle_unusual;
        continue;
      // string bacteria = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bacteria();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.bacteria"));
        } else
          goto handle_unusual;
        continue;
      // string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.description"));
        } else
          goto handle_unusual;
        continue;
      // string processStart = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_processstart();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.processStart"));
        } else
          goto handle_unusual;
        continue;
      // string processLength = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_processlength();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Autoklav.ProcessLogRow.processLength"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessLogRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.ProcessLogRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string productName = 2;
  if (!this->_internal_productname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_productname().data(), static_cast<int>(this->_internal_productname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.productName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_productname(), target);
  }

  // string productQuantity = 3;
  if (!this->_internal_productquantity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_productquantity().data(), static_cast<int>(this->_internal_productquantity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.productQuantity");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_productquantity(), target);
  }

  // string bacteria = 4;
  if (!this->_internal_bacteria().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bacteria().data(), static_cast<int>(this->_internal_bacteria().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.bacteria");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_bacteria(), target);
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  // string processStart = 6;
  if (!this->_internal_processstart().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_processstart().data(), static_cast<int>(this->_internal_processstart().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.processStart");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_processstart(), target);
  }

  // string processLength = 7;
  if (!this->_internal_processlength().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_processlength().data(), static_cast<int>(this->_internal_processlength().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Autoklav.ProcessLogRow.processLength");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_processlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.ProcessLogRow)
  return target;
}

size_t ProcessLogRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.ProcessLogRow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string productName = 2;
  if (!this->_internal_productname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_productname());
  }

  // string productQuantity = 3;
  if (!this->_internal_productquantity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_productquantity());
  }

  // string bacteria = 4;
  if (!this->_internal_bacteria().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bacteria());
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string processStart = 6;
  if (!this->_internal_processstart().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_processstart());
  }

  // string processLength = 7;
  if (!this->_internal_processlength().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_processlength());
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProcessLogRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProcessLogRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProcessLogRow::GetClassData() const { return &_class_data_; }


void ProcessLogRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProcessLogRow*>(&to_msg);
  auto& from = static_cast<const ProcessLogRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.ProcessLogRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_productname().empty()) {
    _this->_internal_set_productname(from._internal_productname());
  }
  if (!from._internal_productquantity().empty()) {
    _this->_internal_set_productquantity(from._internal_productquantity());
  }
  if (!from._internal_bacteria().empty()) {
    _this->_internal_set_bacteria(from._internal_bacteria());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_processstart().empty()) {
    _this->_internal_set_processstart(from._internal_processstart());
  }
  if (!from._internal_processlength().empty()) {
    _this->_internal_set_processlength(from._internal_processlength());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProcessLogRow::CopyFrom(const ProcessLogRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.ProcessLogRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessLogRow::IsInitialized() const {
  return true;
}

void ProcessLogRow::InternalSwap(ProcessLogRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productname_, lhs_arena,
      &other->_impl_.productname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.productquantity_, lhs_arena,
      &other->_impl_.productquantity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bacteria_, lhs_arena,
      &other->_impl_.bacteria_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.processstart_, lhs_arena,
      &other->_impl_.processstart_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.processlength_, lhs_arena,
      &other->_impl_.processlength_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProcessLogRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[8]);
}

// ===================================================================

class StartProcessRequest::_Internal {
 public:
  static const ::Autoklav::ProcessConfig& processconfig(const StartProcessRequest* msg);
  static const ::Autoklav::ProcessInfo& processinfo(const StartProcessRequest* msg);
};

const ::Autoklav::ProcessConfig&
StartProcessRequest::_Internal::processconfig(const StartProcessRequest* msg) {
  return *msg->_impl_.processconfig_;
}
const ::Autoklav::ProcessInfo&
StartProcessRequest::_Internal::processinfo(const StartProcessRequest* msg) {
  return *msg->_impl_.processinfo_;
}
StartProcessRequest::StartProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Autoklav.StartProcessRequest)
}
StartProcessRequest::StartProcessRequest(const StartProcessRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StartProcessRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.processconfig_){nullptr}
    , decltype(_impl_.processinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_processconfig()) {
    _this->_impl_.processconfig_ = new ::Autoklav::ProcessConfig(*from._impl_.processconfig_);
  }
  if (from._internal_has_processinfo()) {
    _this->_impl_.processinfo_ = new ::Autoklav::ProcessInfo(*from._impl_.processinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:Autoklav.StartProcessRequest)
}

inline void StartProcessRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.processconfig_){nullptr}
    , decltype(_impl_.processinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StartProcessRequest::~StartProcessRequest() {
  // @@protoc_insertion_point(destructor:Autoklav.StartProcessRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartProcessRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.processconfig_;
  if (this != internal_default_instance()) delete _impl_.processinfo_;
}

void StartProcessRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartProcessRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:Autoklav.StartProcessRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.processconfig_ != nullptr) {
    delete _impl_.processconfig_;
  }
  _impl_.processconfig_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.processinfo_ != nullptr) {
    delete _impl_.processinfo_;
  }
  _impl_.processinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StartProcessRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Autoklav.ProcessConfig processConfig = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_processconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Autoklav.ProcessInfo processInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_processinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartProcessRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Autoklav.StartProcessRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Autoklav.ProcessConfig processConfig = 1;
  if (this->_internal_has_processconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::processconfig(this),
        _Internal::processconfig(this).GetCachedSize(), target, stream);
  }

  // .Autoklav.ProcessInfo processInfo = 2;
  if (this->_internal_has_processinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::processinfo(this),
        _Internal::processinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Autoklav.StartProcessRequest)
  return target;
}

size_t StartProcessRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Autoklav.StartProcessRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Autoklav.ProcessConfig processConfig = 1;
  if (this->_internal_has_processconfig()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.processconfig_);
  }

  // .Autoklav.ProcessInfo processInfo = 2;
  if (this->_internal_has_processinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.processinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StartProcessRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StartProcessRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StartProcessRequest::GetClassData() const { return &_class_data_; }


void StartProcessRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StartProcessRequest*>(&to_msg);
  auto& from = static_cast<const StartProcessRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Autoklav.StartProcessRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_processconfig()) {
    _this->_internal_mutable_processconfig()->::Autoklav::ProcessConfig::MergeFrom(
        from._internal_processconfig());
  }
  if (from._internal_has_processinfo()) {
    _this->_internal_mutable_processinfo()->::Autoklav::ProcessInfo::MergeFrom(
        from._internal_processinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StartProcessRequest::CopyFrom(const StartProcessRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Autoklav.StartProcessRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartProcessRequest::IsInitialized() const {
  return true;
}

void StartProcessRequest::InternalSwap(StartProcessRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartProcessRequest, _impl_.processinfo_)
      + sizeof(StartProcessRequest::_impl_.processinfo_)
      - PROTOBUF_FIELD_OFFSET(StartProcessRequest, _impl_.processconfig_)>(
          reinterpret_cast<char*>(&_impl_.processconfig_),
          reinterpret_cast<char*>(&other->_impl_.processconfig_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StartProcessRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_autoklav_2eproto_getter, &descriptor_table_autoklav_2eproto_once,
      file_level_metadata_autoklav_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Autoklav
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Autoklav::Empty*
Arena::CreateMaybeMessage< ::Autoklav::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::Status*
Arena::CreateMaybeMessage< ::Autoklav::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::Variables*
Arena::CreateMaybeMessage< ::Autoklav::Variables >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::Variables >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::SetVariable*
Arena::CreateMaybeMessage< ::Autoklav::SetVariable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::SetVariable >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::SensorValues*
Arena::CreateMaybeMessage< ::Autoklav::SensorValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::SensorValues >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::StateMachineValues*
Arena::CreateMaybeMessage< ::Autoklav::StateMachineValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::StateMachineValues >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::ProcessConfig*
Arena::CreateMaybeMessage< ::Autoklav::ProcessConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::ProcessConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::ProcessInfo*
Arena::CreateMaybeMessage< ::Autoklav::ProcessInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::ProcessInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::ProcessLogRow*
Arena::CreateMaybeMessage< ::Autoklav::ProcessLogRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::ProcessLogRow >(arena);
}
template<> PROTOBUF_NOINLINE ::Autoklav::StartProcessRequest*
Arena::CreateMaybeMessage< ::Autoklav::StartProcessRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Autoklav::StartProcessRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
