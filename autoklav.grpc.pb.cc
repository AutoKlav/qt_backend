// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: autoklav.proto

#include "autoklav.pb.h"
#include "autoklav.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace Autoklav {

static const char* Autoklav_method_names[] = {
  "/Autoklav.Autoklav/getStatus",
  "/Autoklav.Autoklav/getVariables",
  "/Autoklav.Autoklav/setVariable",
  "/Autoklav.Autoklav/startProcess",
  "/Autoklav.Autoklav/stopProcess",
  "/Autoklav.Autoklav/getSensorValues",
  "/Autoklav.Autoklav/getStateMachineValues",
};

std::unique_ptr< Autoklav::Stub> Autoklav::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Autoklav::Stub> stub(new Autoklav::Stub(channel, options));
  return stub;
}

Autoklav::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_getStatus_(Autoklav_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getVariables_(Autoklav_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_setVariable_(Autoklav_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_startProcess_(Autoklav_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_stopProcess_(Autoklav_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getSensorValues_(Autoklav_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getStateMachineValues_(Autoklav_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Autoklav::Stub::getStatus(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::Autoklav::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getStatus_, context, request, response);
}

void Autoklav::Stub::async::getStatus(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getStatus_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::getStatus(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getStatus_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::Status, ::Autoklav::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getStatus_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetStatusRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::getVariables(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::Autoklav::Variables* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::Empty, ::Autoklav::Variables, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getVariables_, context, request, response);
}

void Autoklav::Stub::async::getVariables(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Variables* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::Empty, ::Autoklav::Variables, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getVariables_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::getVariables(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Variables* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getVariables_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Variables>* Autoklav::Stub::PrepareAsyncgetVariablesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::Variables, ::Autoklav::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getVariables_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Variables>* Autoklav::Stub::AsyncgetVariablesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetVariablesRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::setVariable(::grpc::ClientContext* context, const ::Autoklav::SetVariable& request, ::Autoklav::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::SetVariable, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_setVariable_, context, request, response);
}

void Autoklav::Stub::async::setVariable(::grpc::ClientContext* context, const ::Autoklav::SetVariable* request, ::Autoklav::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::SetVariable, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_setVariable_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::setVariable(::grpc::ClientContext* context, const ::Autoklav::SetVariable* request, ::Autoklav::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_setVariable_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::PrepareAsyncsetVariableRaw(::grpc::ClientContext* context, const ::Autoklav::SetVariable& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::Status, ::Autoklav::SetVariable, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_setVariable_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::AsyncsetVariableRaw(::grpc::ClientContext* context, const ::Autoklav::SetVariable& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncsetVariableRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::startProcess(::grpc::ClientContext* context, const ::Autoklav::StartProcessRequest& request, ::Autoklav::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::StartProcessRequest, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_startProcess_, context, request, response);
}

void Autoklav::Stub::async::startProcess(::grpc::ClientContext* context, const ::Autoklav::StartProcessRequest* request, ::Autoklav::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::StartProcessRequest, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_startProcess_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::startProcess(::grpc::ClientContext* context, const ::Autoklav::StartProcessRequest* request, ::Autoklav::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_startProcess_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::PrepareAsyncstartProcessRaw(::grpc::ClientContext* context, const ::Autoklav::StartProcessRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::Status, ::Autoklav::StartProcessRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_startProcess_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::AsyncstartProcessRaw(::grpc::ClientContext* context, const ::Autoklav::StartProcessRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncstartProcessRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::stopProcess(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::Autoklav::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_stopProcess_, context, request, response);
}

void Autoklav::Stub::async::stopProcess(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_stopProcess_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::stopProcess(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_stopProcess_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::PrepareAsyncstopProcessRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::Status, ::Autoklav::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_stopProcess_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::Status>* Autoklav::Stub::AsyncstopProcessRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncstopProcessRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::getSensorValues(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::Autoklav::SensorValues* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::Empty, ::Autoklav::SensorValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getSensorValues_, context, request, response);
}

void Autoklav::Stub::async::getSensorValues(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::SensorValues* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::Empty, ::Autoklav::SensorValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getSensorValues_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::getSensorValues(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::SensorValues* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getSensorValues_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::SensorValues>* Autoklav::Stub::PrepareAsyncgetSensorValuesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::SensorValues, ::Autoklav::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getSensorValues_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::SensorValues>* Autoklav::Stub::AsyncgetSensorValuesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetSensorValuesRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Autoklav::Stub::getStateMachineValues(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::Autoklav::StateMachineValues* response) {
  return ::grpc::internal::BlockingUnaryCall< ::Autoklav::Empty, ::Autoklav::StateMachineValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getStateMachineValues_, context, request, response);
}

void Autoklav::Stub::async::getStateMachineValues(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::StateMachineValues* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::Autoklav::Empty, ::Autoklav::StateMachineValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getStateMachineValues_, context, request, response, std::move(f));
}

void Autoklav::Stub::async::getStateMachineValues(::grpc::ClientContext* context, const ::Autoklav::Empty* request, ::Autoklav::StateMachineValues* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getStateMachineValues_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::StateMachineValues>* Autoklav::Stub::PrepareAsyncgetStateMachineValuesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::Autoklav::StateMachineValues, ::Autoklav::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getStateMachineValues_, context, request);
}

::grpc::ClientAsyncResponseReader< ::Autoklav::StateMachineValues>* Autoklav::Stub::AsyncgetStateMachineValuesRaw(::grpc::ClientContext* context, const ::Autoklav::Empty& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetStateMachineValuesRaw(context, request, cq);
  result->StartCall();
  return result;
}

Autoklav::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::Empty* req,
             ::Autoklav::Status* resp) {
               return service->getStatus(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::Empty, ::Autoklav::Variables, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::Empty* req,
             ::Autoklav::Variables* resp) {
               return service->getVariables(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::SetVariable, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::SetVariable* req,
             ::Autoklav::Status* resp) {
               return service->setVariable(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::StartProcessRequest, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::StartProcessRequest* req,
             ::Autoklav::Status* resp) {
               return service->startProcess(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::Empty, ::Autoklav::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::Empty* req,
             ::Autoklav::Status* resp) {
               return service->stopProcess(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::Empty, ::Autoklav::SensorValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::Empty* req,
             ::Autoklav::SensorValues* resp) {
               return service->getSensorValues(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Autoklav_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Autoklav::Service, ::Autoklav::Empty, ::Autoklav::StateMachineValues, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Autoklav::Service* service,
             ::grpc::ServerContext* ctx,
             const ::Autoklav::Empty* req,
             ::Autoklav::StateMachineValues* resp) {
               return service->getStateMachineValues(ctx, req, resp);
             }, this)));
}

Autoklav::Service::~Service() {
}

::grpc::Status Autoklav::Service::getStatus(::grpc::ServerContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::getVariables(::grpc::ServerContext* context, const ::Autoklav::Empty* request, ::Autoklav::Variables* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::setVariable(::grpc::ServerContext* context, const ::Autoklav::SetVariable* request, ::Autoklav::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::startProcess(::grpc::ServerContext* context, const ::Autoklav::StartProcessRequest* request, ::Autoklav::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::stopProcess(::grpc::ServerContext* context, const ::Autoklav::Empty* request, ::Autoklav::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::getSensorValues(::grpc::ServerContext* context, const ::Autoklav::Empty* request, ::Autoklav::SensorValues* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Autoklav::Service::getStateMachineValues(::grpc::ServerContext* context, const ::Autoklav::Empty* request, ::Autoklav::StateMachineValues* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace Autoklav

